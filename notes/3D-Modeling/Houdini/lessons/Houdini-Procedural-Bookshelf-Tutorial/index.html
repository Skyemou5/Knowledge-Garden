<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Download the Example FIle for a closer look.
 [!NOTE] However if you are learning I highly recommend setting this up yourself and then checking your work with the file"><title>Houdini Procedural Bookshelf Tutorial</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://notes.benshurts.com//icon.png><link href=https://notes.benshurts.com/styles.708c2658f93e3a9d323a1f9fded8f4b2.min.css rel=stylesheet><link href=https://notes.benshurts.com/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://notes.benshurts.com/js/darkmode.7f1fd235efdec6a4bdcb4d8d99113082.min.js></script>
<script src=https://notes.benshurts.com/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://notes.benshurts.com/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://notes.benshurts.com/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://notes.benshurts.com/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://notes.benshurts.com/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://notes.benshurts.com/",fetchData=Promise.all([fetch("https://notes.benshurts.com/indices/linkIndex.e6a4ccf726908ae3562f1a32ea428495.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://notes.benshurts.com/indices/contentIndex.b16736ba5796ac0f29c8484596b0a5b2.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://notes.benshurts.com",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://notes.benshurts.com",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/notes.benshurts.com\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://notes.benshurts.com/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://notes.benshurts.com/>Knowledge Garden</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Houdini Procedural Bookshelf Tutorial</h1><p class=meta>Last updated
Jul 7, 2023
<a href=https://github.com/benshurts/Knowledge-Garden/notes/3D-Modeling/Houdini/lessons/Houdini%20Procedural%20Bookshelf%20Tutorial.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://notes.benshurts.com/tags/houdini/>Houdini</a></li><li><a href=https://notes.benshurts.com/tags/procedural/>Procedural</a></li><li><a href=https://notes.benshurts.com/tags/setups/>Setups</a></li><li><a href=https://notes.benshurts.com/tags/tutorial/>Tutorial</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#first-line-node>First line Node</a></li><li><a href=#controller-node>Controller Node</a><ol><li><a href=#copy-parameters-from-controller>Copy Parameters from Controller</a></li><li><a href=#null-in-node>Null IN node</a></li><li><a href=#first-resample-node>First Resample Node</a></li></ol></li></ol><ol><li><a href=#end-boards>End boards</a><ol><li><a href=#separate-end-points-with-wrangle>Separate end points with wrangle</a></li><li><a href=#split-node-to-split-out-the-end-points>Split node to split out the end points</a></li><li><a href=#add-node-to-remove-edges>Add node to remove edges</a></li><li><a href=#second-line-node-for-height>Second Line node for height</a></li><li><a href=#copy-to-points-for-the-end-boards>Copy to points for the end boards</a></li><li><a href=#first-sweep-node>First Sweep Node</a></li><li><a href=#extrude-end-boards>Extrude end boards</a></li></ol></li><li><a href=#bottom-boards>Bottom Boards</a><ol><li><a href=#horizontal-line>Horizontal line</a></li><li><a href=#copy-to-points-boards>Copy to points boards</a></li><li><a href=#remove-last-point-wrangle>Remove last point wrangle</a></li><li><a href=#board-geo>Board Geo</a></li></ol></li><li><a href=#vertical-separators>Vertical Separators</a><ol><li><a href=#creating-the-vertical-boards>Creating the vertical boards</a></li></ol></li><li><a href=#ptdist-attribute>ptdist attribute</a><ol><li><a href=#attribute-promote>Attribute Promote</a></li><li><a href=#attribute-wrangle>Attribute Wrangle</a></li></ol></li><li><a href=#shelves>Shelves</a><ol><li><a href=#loops>Loops</a></li></ol></li><li><a href=#top-board>Top Board</a></li></ol><ol><li><a href=#defining-the-problem-for-uvs>Defining the problem for UVs</a></li><li><a href=#setting-up-initial-uvs>Setting up initial UVs</a><ol><li><a href=#fixing-uvs-for-vertical-boards>Fixing UVs for vertical boards</a></li></ol></li><li><a href=#uv-layout>UV layout</a><ol><li><a href=#align-uvs>Align UVs</a></li></ol></li></ol></nav></details></aside><p>Download the
<a href=https://github.com/benshurts/Knowledge-Garden/blob/hugo/content/notes/3D-Modeling/Houdini/example-files/simple-bookshelf/simple-bookshelf.hiplc rel=noopener>Example FIle</a> for a closer look.</p><blockquote class=note-callout><p>However if you are learning I highly recommend setting this up yourself and then checking your work with the file</p></blockquote><p>This is a simple setup for a procedural bookshelf in houdini.</p><blockquote class=note-callout><p>Obviously there are infinite ways to set this up, this is just the way I decided to do it</p></blockquote><p>I am going to set this up so it&rsquo;s easy to expand with more features down the road.</p><hr><a href=#initial-setup-and-prep><h1 id=initial-setup-and-prep><span class=hanchor arialabel=Anchor># </span>Initial Setup and Prep</h1></a><blockquote class=info-callout><p>For this setup we are going use a point based workflow.</p></blockquote><p>First drop down a <code>null</code> and call it <code>CONTROLLER</code> or something like that.</p><p><img src=/notes/attachments/houdini-controller-null-example-node.png width=auto></p><blockquote class=hint-callout><p>You can hit <code>C</code> to bring up the color palette and <code>Z</code> to bring up the node shape palette to make the node look like the above.</p></blockquote><blockquote class=note-callout><p>This <code>null</code> controller workflow is very helpful once we get into <a href=/notes/3D-Modeling/Houdini/lessons/Houdini-HDAs rel=noopener class=internal-link data-src=/notes/3D-Modeling/Houdini/lessons/Houdini-HDAs>Houdini HDAs</a> and tool building.</p></blockquote><p>Right away, we already know we will want to control some of the main parameters of this bookshelf:</p><ul><li>Height</li><li>Width</li><li>Depth</li></ul><blockquote><p>And a few others you will see below</p></blockquote><p>So let&rsquo;s add those to the parameters on the null.</p><blockquote class=note-callout><p>To access the parameters on any node including this null click on the gear icon in the parameters window an select <code>edit parameter interface</code></p><p><img src=/notes/attachments/houdini-edit-parm-interface.png width=auto></p></blockquote><p>There are many ways to add parameters. But for now just drag over from the list into the middle window.</p><p><img src=/notes/attachments/houdini-parameter-interface-drag.png width=auto></p><p>Then make sure you have named the parameter correctly.</p><p><img src=/notes/attachments/houdini-parm-names.png width=auto></p><blockquote class=note-callout><p>the two fields that I have named the same actually serve different purposes. The label is what you see in the interface. The name is it&rsquo;s ID under the hood. This is important if you end up scripting with python and need to target a parameter. I think it&rsquo;s a good habit to make them the same for now.</p></blockquote><p>You could also add a folder called <code>master controls</code> or something like that to keep your interface organized.</p><p>Go ahead and add the following parameters:</p><p><img src=/notes/attachments/houdini-simple-bookshelf-parms.png width=auto></p><a href=#first-nodes-setup><h1 id=first-nodes-setup><span class=hanchor arialabel=Anchor># </span>First Nodes Setup</h1></a><p>For now let&rsquo;s set this up with a line at first.</p><a href=#first-line-node><h2 id=first-line-node><span class=hanchor arialabel=Anchor># </span>First line Node</h2></a><ol><li>Drop down a <code>line</code> node.</li><li>Set the direction to be left or right <em>not</em> up or down. <img src="/notes/attachments/Pasted image 20230517115204.png" width=auto></li></ol><blockquote class=important-callout><p>This will determine the total width of the bookshelf.</p></blockquote><a href=#controller-node><h2 id=controller-node><span class=hanchor arialabel=Anchor># </span>Controller Node</h2></a><p>Now let&rsquo;s start using our controller.</p><a href=#copy-parameters-from-controller><h3 id=copy-parameters-from-controller><span class=hanchor arialabel=Anchor># </span>Copy Parameters from Controller</h3></a><p>First, right click on the <code>width</code> (or whatever you named it, it should be the length or width of the bookshelf) parameter and select <code>copy parameter</code>.</p><p><img src=/notes/attachments/houdini-copy-parm.png width=auto></p><p>Then on the <code>line</code> node right click on the <code>lenght</code> parameter and select <code>paste relative references</code>.</p><p><img src=/notes/attachments/houdini-paste-relative-references.png width=auto></p><p>Now the lines length will be controlled by the slider on your controller.</p><blockquote class=note-callout><p>I often work with two parameter windows open when I do controllers. One I pin to the controller and the other will follow my selection.</p><p><img src=/notes/attachments/houdini-split-parm-pinned.png width=auto></p></blockquote><a href=#null-in-node><h3 id=null-in-node><span class=hanchor arialabel=Anchor># </span>Null IN node</h3></a><blockquote class=hint-callout><p>Next you can drop down a <code>null</code>. I named it <code>IN_curve</code>. This is just so in the future we have a clear input point and if we want to upgrade our setup we can.</p><p><img src=/notes/attachments/houdini-bookshelf-IN.png width=auto></p></blockquote><a href=#first-resample-node><h3 id=first-resample-node><span class=hanchor arialabel=Anchor># </span>First Resample Node</h3></a><p>Next, drop down a <code>resample</code> node.</p><p><img src=/notes/attachments/houdini-bookshelf-first-resample.png width=auto></p><p>This will determine the distance between the separator boards.</p><p><img src=/notes/attachments/houdini-bookshelf-separator-boards.png width=auto></p><p><img src=/notes/attachments/houdini-resample-on-line.png width=auto></p><blockquote class=note-callout><p>Check the
<a href=https://www.sidefx.com/docs/houdini/nodes/sop/resample.html rel=noopener>Resample Node Documentation</a>for more info. The resample node splits up line segments by distance or amount.</p></blockquote><p>We need to check one box on the <code>resample</code> node:</p><ul><li><code>Distance Attribute</code></li></ul><p><img src=/notes/attachments/houdini-resample-distance-attrib.png width=auto></p><p>This will help us determine the length of the boards later in the stream.</p><blockquote class=note-callout><p>Houdini attributes are data that can be attached to points, verts, prims, or the whole object (detail). For more info refer to the documentation
<a href=https://www.sidefx.com/docs/houdini/model/attributes.html rel=noopener>Geometry attributes</a>We will be using attributes and groups in this lesson.</p></blockquote><a href=#bookshelf-components><h1 id=bookshelf-components><span class=hanchor arialabel=Anchor># </span>Bookshelf Components</h1></a><p>Ok we now have the foundation set for the rest of the setup.</p><p>let&rsquo;s outline the components and how we want them to behave:</p><p>Components:</p><ul><li>End vertical boards</li><li>Intermediate separator boards</li><li>Shelves</li><li>Top board</li></ul><p>These should automatically generate with the size of the bookshelf and the parameters we set for separation between shelves and separators.</p><a href=#end-boards><h2 id=end-boards><span class=hanchor arialabel=Anchor># </span>End boards</h2></a><p>These boards will be mark the ends of our bookshelf.</p><a href=#separate-end-points-with-wrangle><h3 id=separate-end-points-with-wrangle><span class=hanchor arialabel=Anchor># </span>Separate end points with wrangle</h3></a><p>So we have the resampled line. We will be using a <code>copy to points</code> node to put the pieces where we want them. So we will want to separate out the the first and last points. The easiest way to do this is in a <code>point wrangle</code> with <code>vex</code>.</p><blockquote class=important-callout><p>Don&rsquo;t worry if you don&rsquo;t understand the vex yet. I&rsquo;ll do my best to explain. It&rsquo;s not too scary.</p></blockquote><p><img src=/notes/attachments/houdini-bookshelf-wrangle-endpoints.png width=auto></p><p>In the node copy the following code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>npts</span> <span class=o>=</span> <span class=n>npoints</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>//npoints is the total number of points in the geo stream
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Store the first point in a variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>firstPoint</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span> <span class=n>firstPosition</span> <span class=o>=</span> <span class=n>point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;P&#34;</span><span class=p>,</span> <span class=n>firstPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>setpointgroup</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;firstlast&#34;</span><span class=p>,</span> <span class=n>firstPoint</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Store the last point in a variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>lastPoint</span> <span class=o>=</span> <span class=err>@</span><span class=n>numpt</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=err>@</span><span class=n>lastpnt</span> <span class=o>=</span> <span class=n>lastPoint</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span> <span class=n>lastPosition</span> <span class=o>=</span> <span class=n>point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;P&#34;</span><span class=p>,</span> <span class=n>lastPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>setpointgroup</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;firstlast&#34;</span><span class=p>,</span> <span class=n>lastPoint</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class="callout-collapsible callout-collapsed hint-callout"><p>Here is an explanation of the code:</p><p>#code-explanation</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>npts</span> <span class=o>=</span> <span class=n>npoints</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// npoints is the total number of points in the geo stream
</span></span></span></code></pre></td></tr></table></div></div><ul><li>The variable <code>npts</code> is declared as an integer and assigned the value of the total number of points in the geometry stream (<code>0</code>).</li><li>The <code>npoints()</code> function returns the number of points in the stream, and by subtracting <code>1</code>, the variable <code>npts</code> represents the index of the last point in the stream.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>firstPoint</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The variable <code>firstPoint</code> is declared as an integer and assigned the value <code>0</code>.</li><li>This variable will be used to store the index of the first point in the stream.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>vector</span> <span class=n>firstPosition</span> <span class=o>=</span> <span class=n>point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;P&#34;</span><span class=p>,</span> <span class=n>firstPoint</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The variable <code>firstPosition</code> is declared as a vector.</li><li>The <code>point()</code> function retrieves the position (&ldquo;P&rdquo;) of the point at index <code>firstPoint</code> in the geometry stream (<code>0</code>).</li><li>The retrieved position, a three-dimensional vector representing the coordinates of the point in 3D space, is assigned to the <code>firstPosition</code> variable.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>setpointgroup</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;firstlast&#34;</span><span class=p>,</span> <span class=n>firstPoint</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The <code>setpointgroup()</code> function is called to set a point group named &ldquo;firstlast&rdquo;.</li><li>The arguments provided to the function are the geometry stream (<code>0</code>), the name of the point group (&ldquo;firstlast&rdquo;), the index of the point (<code>firstPoint</code>), and a value of <code>1</code>.</li><li>This effectively adds the <code>firstPoint</code> to the &ldquo;firstlast&rdquo; point group.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>lastPoint</span> <span class=o>=</span> <span class=err>@</span><span class=n>numpt</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=err>@</span><span class=n>lastpnt</span> <span class=o>=</span> <span class=n>lastPoint</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The variable <code>lastPoint</code> is declared as an integer and assigned the value of the attribute <code>@numpt</code> (the total number of points in the current geometry).</li><li>By subtracting <code>1</code>, <code>lastPoint</code> represents the index of the last point in the stream.</li><li>The <code>@lastpnt</code> attribute is then set to the value of <code>lastPoint</code>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>vector</span> <span class=n>lastPosition</span> <span class=o>=</span> <span class=n>point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;P&#34;</span><span class=p>,</span> <span class=n>lastPoint</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>The variable <code>lastPosition</code> is declared as a vector.</li><li>The <code>point()</code> function retrieves the position (&ldquo;P&rdquo;) of the point at index <code>lastPoint</code> in the geometry stream (<code>0</code>).</li><li>The retrieved position is assigned to the <code>lastPosition</code> variable.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>setpointgroup</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;firstlast&#34;</span><span class=p>,</span> <span class=n>lastPoint</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This line adds the <code>lastPoint</code> to the &ldquo;firstlast&rdquo; point group using the <code>setpointgroup()</code> function.</p><p>In summary, this code retrieves the positions of the first and last points in a geometry stream and stores them in <code>firstPosition</code> and <code>lastPosition</code>, respectively. Additionally, it adds the first and last points to a point group named &ldquo;firstlast&rdquo;.</p></blockquote><a href=#split-node-to-split-out-the-end-points><h3 id=split-node-to-split-out-the-end-points><span class=hanchor arialabel=Anchor># </span>Split node to split out the end points</h3></a><p>Next we will drop down a <code>split</code> node.</p><p><img src=/notes/attachments/houdini-split-node.png width=auto></p><p>This will split the geo-stream by group. We created a group in the wrangle so now we will use it here.</p><p><img src=/notes/attachments/houdini-split-node-group-parms.png width=auto></p><blockquote class="callout-collapsible callout-collapsed note-callout"><p>Checking for groups</p><p>There are a few ways you can check for attributes and groups on any node.</p><ol><li>Middle click on a node to bring up the node info. This will show all the data about that node.</li><li>Hover over a node till the <code>node ring</code> shows up</li></ol><ul><li><img src=/notes/attachments/houdini-node-ring.png width=auto></li></ul><ol start=2><li>Click on the <code>i</code><ul><li><img src=/notes/attachments/houdini-ring-info.png width=auto></li></ul></li></ol><p>This will bring up the info window:</p><p><img src="/notes/attachments/Pasted image 20230517131203.png" width=auto></p><p>The other way is checking the <code>geometry spreadsheet</code></p><p>The spreadsheet will show all the data for any node selected.</p><p><img src=/notes/attachments/houdini-group-in-spreadsheet.png width=auto></p><p>There is a lot to learn about the <code>geometry spreadsheet</code>, check the documentation for more info ->
<a href=https://www.sidefx.com/docs/houdini/ref/panes/geosheet.html rel=noopener>Geometry Spreadsheet pane</a></p></blockquote><p>Now the stream is separated between the first and last points and the ones in the middle.</p><a href=#add-node-to-remove-edges><h3 id=add-node-to-remove-edges><span class=hanchor arialabel=Anchor># </span>Add node to remove edges</h3></a><p>The next thing I&rsquo;m going to do it wire-in an
<a href=https://www.sidefx.com/docs/houdini/nodes/sop/add.html rel=noopener>Add</a>
node to output of the split that just has the ends.</p><blockquote class=note-callout><p>This is just to clean things up.</p></blockquote><p>On the <code>add</code> node I&rsquo;m going to check <code>Delete Geometry But Keep Points</code></p><p><img src=/notes/attachments/houdini-keep-points-add-node.png width=auto></p><p>This is where things start to get a little more complex.</p><a href=#second-line-node-for-height><h3 id=second-line-node-for-height><span class=hanchor arialabel=Anchor># </span>Second Line node for height</h3></a><p>Next we want to drop down another <code>line</code> node.</p><p>This line should be facing upwards on the <code>Y</code> axis and we should copy out <code>height</code> parameter into the <code>length</code> of the line.</p><blockquote class=important-callout><p>This line will be <em>height</em> of our bookshelf!</p></blockquote><p><img src=/notes/attachments/houdini-bookshelf-height-line.png width=auto></p><a href=#copy-to-points-for-the-end-boards><h3 id=copy-to-points-for-the-end-boards><span class=hanchor arialabel=Anchor># </span>Copy to points for the end boards</h3></a><p>Next we will drop down a
<a href=https://www.sidefx.com/docs/houdini/nodes/sop/copytopoints.html rel=noopener>Copy to Points</a> node.</p><blockquote class=note-callout><p>The <code>Copy to Points</code> node will allow us to copy anything to any points we feed into it.</p></blockquote><p><img src=/notes/attachments/houdini-bookshelf-ctp-ends.png width=auto></p><ol><li>geometry to copy</li><li>points to copy to</li></ol><p>Now you should have two lines pointing up like so:</p><p><img src=/notes/attachments/houdini-bookshlef-ctp-ends-result-line.png width=auto></p><a href=#first-sweep-node><h3 id=first-sweep-node><span class=hanchor arialabel=Anchor># </span>First Sweep Node</h3></a><p>Next let&rsquo;s drop down a
<a href=https://www.sidefx.com/docs/houdini/nodes/sop/sweep.html rel=noopener>Sweep</a> node. and wire it into the output of the <code>copy to points</code>.</p><p><img src=/notes/attachments/houdini-bookshelf-sweep-ends.png width=auto></p><p>There are two parameters on the <code>sweep</code> node we need to worry about.</p><ol><li>Surface Shape</li><li>Width</li></ol><p><img src=/notes/attachments/houdini-bookshelf-sweep-parms.png width=auto></p><ul><li>Change the surface shape to ribbon.</li><li>Then change the columns to <code>1</code>.</li></ul><blockquote class=note-callout><p>Ribbon will make it so houdini creates quads that follow the input curve.</p></blockquote><p>Copy in our <code>Depth</code> parameter from the <code>CONTROLLER</code> into the <code>width</code> parameter on the <code>sweep</code> node.</p><p>Now you should be able to control the height, width, and depth of the ends like so:</p><p><img src=/notes/attachments/houdini-bookshelf-ends-animation.gif width=auto></p><a href=#extrude-end-boards><h3 id=extrude-end-boards><span class=hanchor arialabel=Anchor># </span>Extrude end boards</h3></a><p>Next we&rsquo;ll drop down a
<a href=https://www.sidefx.com/docs/houdini/nodes/sop/polyextrude.html rel=noopener>Poly Extrude</a> node and wire it into the output of the <code>sweep</code> node.</p><blockquote class=note-callout><p>The <code>poly extrude</code> node will extrude just like in other 3D packages.</p></blockquote><p>This is how we will get thickness in our boards.</p><p><img src=/notes/attachments/houdini-bookshelf-extrude-ends.png width=auto></p><p>The only parameter we care about here is <code>Distance</code>. We will reference our <code>Board Thickness</code> parameter from our <code>CONTROLLER</code> here.</p><p><img src=/notes/attachments/houdini-bookshelf-board-thickness-extrude.png width=auto></p><p>It should now look like this:</p><p><img src=/notes/attachments/houdini-bookshelf-extruded-viewport.png width=auto></p><blockquote class="callout-collapsible callout-collapsed hint-callout"><p>Organizing the network</p><p>You can create a frame around selected nodes by pressing <code>SHIFT+O</code></p><p><img src=/notes/attachments/houdini-node-frame.gif width=auto></p></blockquote><p>Your network should look something like this now:</p><p><img src=/notes/attachments/hou-bookshelf-network-01.png width=auto></p><a href=#bottom-boards><h2 id=bottom-boards><span class=hanchor arialabel=Anchor># </span>Bottom Boards</h2></a><a href=#horizontal-line><h3 id=horizontal-line><span class=hanchor arialabel=Anchor># </span>Horizontal line</h3></a><p>Next we will create another <code>line</code> node.</p><p>Wire in a <code>null</code> into the lines output and call it <code>OUT_horizontal_line</code>.</p><p><img src=/notes/attachments/hou_bookshlef_horiz_line_OUT.png width=auto></p><blockquote class=note-callout><p>I put this line in another frame for setup objects, because we will reuse this line for more components.</p></blockquote><a href=#copy-to-points-boards><h3 id=copy-to-points-boards><span class=hanchor arialabel=Anchor># </span>Copy to points boards</h3></a><p>Drop down a new <code>copy to points</code> node.</p><p>Now connect the OUT of the new line to <em>left</em> side of the new <code>copy to points</code> node.</p><p>Now wire in the output of the first <code>resample</code> node into the <em>right</em> input of the new <code>copy to points</code>.</p><p>You&rsquo;ll probably notice there is a problem. The lines extend past the edge of the bookshelf. So let&rsquo;s fix this:</p><a href=#remove-last-point-wrangle><h3 id=remove-last-point-wrangle><span class=hanchor arialabel=Anchor># </span>Remove last point wrangle</h3></a><p>Between the first <code>resample</code> and the boards <code>copy to points</code> we just put down, drop down a new <code>attribute wrangle</code>.</p><p>Copy this code into it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>removepoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=err>@</span><span class=n>numpt</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>This will remove the last point in the array.</p><p>Now it doesn&rsquo;t extend past the edge.</p><a href=#board-geo><h3 id=board-geo><span class=hanchor arialabel=Anchor># </span>Board Geo</h3></a><p>This part is easy. Just copy the <code>sweep</code> and <code>poly extrude</code> nodes you made before.</p><blockquote class=note-callout><p>You can copy nodes with <code>CNTRL+C</code> and paste with <code>CNTRL+V</code> <em>OR</em> hold <code>ALT</code> and drag nodes and they will copy.</p><p><img src=/notes/attachments/alt-drag-hou.gif width=auto></p></blockquote><blockquote class=important-callout><p>Copying these nodes will <em>ALSO</em> copy the references inside them so you don&rsquo;t need to set it up again.</p></blockquote><p><img src=/notes/attachments/hou_bookshelf_bottom_board_sweep_ext.png width=auto></p><p>Now let&rsquo;s add a <code>transform</code> node below those two and set an offset of <code>0.05</code> in the <code>Y</code> direction to move them up a bit.</p><a href=#vertical-separators><h2 id=vertical-separators><span class=hanchor arialabel=Anchor># </span>Vertical Separators</h2></a><p>You&rsquo;ve probably noticed that the bottom boards aren&rsquo;t the correct length. This will get a little more complicated than before, so follow along closely.</p><p>There are a few things we need to do to fix this.</p><blockquote class=important-callout><p>This is where we will use the <code>ptdist</code> attribute we turned on in the resample node.</p></blockquote><a href=#creating-the-vertical-boards><h3 id=creating-the-vertical-boards><span class=hanchor arialabel=Anchor># </span>Creating the vertical boards</h3></a><p>Firs thing we&rsquo;ll do is copy the entire <code>copy to points</code> <code>sweet</code> <code>poly extrude</code> chain from before.</p><p>Then we wire in the vertical line we made into the <em>left</em> slot of the copy to points.</p><p>Next, take the <em>right</em> output from the <code>split</code> node and wire it into the <em>right</em> side of the new <code>copy to points</code> node.</p><p>You should have one or more vertical boards like this:</p><p><img src=/notes/attachments/hou-bookshlef-vert-boards.png width=auto></p><a href=#ptdist-attribute><h2 id=ptdist-attribute><span class=hanchor arialabel=Anchor># </span>ptdist attribute</h2></a><blockquote class=info-callout><p>The reason I am using the <code>ptdist</code> attribute instead of just the <code>Length</code> parameter from the <code>resample</code> node is for two reasons:</p><ol><li>What if I don&rsquo;t want to use the <code>length</code> parm and instead want to use amount?</li><li>The <code>Length</code> results in some wiggle room and imprecise distances as things change. For this we need precision.</li></ol></blockquote><p>One of the problems we have to solve is how do we get the information of the distance between points to the line distance and anywhere else we need it.</p><p>We will drop down 3 nodes:</p><ul><li><code>Attribute Promote</code></li><li><code>Attribute Wrangle</code></li><li><code>null</code></li></ul><p>Hook them up respectively.</p><p><img src=/notes/attachments/hou-bookshelf-ptdist.png width=auto></p><a href=#attribute-promote><h3 id=attribute-promote><span class=hanchor arialabel=Anchor># </span>Attribute Promote</h3></a><p>The first node is an <code>attribute promote</code>, This node lets up change type of an attribute. In our case we just need to worry about two fields.</p><ol><li><code>original name</code></li><li><code>new class</code></li></ol><p>set <code>ptdist</code> in the first one. and set the <code>new class</code> to <code>Detail</code></p><blockquote class=note-callout><p><code>Detail</code> attributes are not stored on components but instead on the object level. We only need this stored once, so we save computation by not putting it on points.</p></blockquote><a href=#attribute-wrangle><h3 id=attribute-wrangle><span class=hanchor arialabel=Anchor># </span>Attribute Wrangle</h3></a><p>In this wrangle we will solve a strange behavior that caused me some problems. The problem was that because we were using the distance attribute when there was no extra points being created in the resample that attribute was set to 0. So we need to correct it.</p><p>What we will do is check whether the attribute is zero, if it is we will set it to the length of the bookself.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=err>@</span><span class=n>ptdist</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=n>ptdist</span> <span class=o>=</span> <span class=n>chf</span><span class=p>(</span><span class=s>&#34;dist&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=note-callout><p>To create a parameter in vex you use channel expressions. In this case <code>chf</code> stands for channel float. or a float channel. The argument is a string indicating the name it will have.
Then you click the slider button in the wrangle.</p><p><img src=/notes/attachments/hou-wrangle-add-parms-button.png width=auto></p></blockquote><p>Now copy in the <code>length</code> parm from the <code>CONTROLLER</code> into the new parameter.</p><p><img src=/notes/attachments/hou-bookshelf-fix-dist-parm.png width=auto></p><p>Now name the <code>null</code> something like <code>OUT_ptdist</code>.</p><a href=#shelves><h2 id=shelves><span class=hanchor arialabel=Anchor># </span>Shelves</h2></a><p>Now we will use the <code>ptdist</code> attribute. In this case we will use an <em>expression</em> inside a parameter.</p><blockquote class=note-callout><p>Houdini uses <code>HScript</code> or <code>Python</code> as an expression language. HScript is similar to linux command line languages like <code>Bash</code>. You can check the <em>documentation</em> for more info
<a href=https://www.sidefx.com/docs/houdini/expressions/index.html rel=noopener>Expression functions</a></p></blockquote><p>In the <em>horizontal</em> <code>line</code> node we created earlier is where we will write this expression.</p><blockquote class=important-callout><p>In this case I am using <code>HScript</code></p></blockquote><p>The expression is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>abs</span><span class=p>(</span><span class=n>detail</span><span class=p>(</span><span class=s2>&#34;../OUT_ptdist_attrib/&#34;</span><span class=p>,</span><span class=s2>&#34;ptdist&#34;</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span><span class=o>-</span><span class=n>ch</span><span class=p>(</span><span class=s2>&#34;../CONTROLLER/board_thickness&#34;</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=/notes/attachments/hou-bookshelf-line-len-expression.png width=auto></p><ol><li><code>abs()</code> is a function that calculates the absolute value of a number. It ensures that the result is always positive.</li><li><code>detail()</code> function is used to access attribute values from another geometry in the scene. In this case, it is accessing the attribute named &ldquo;ptdist&rdquo; from the geometry located at the relative path &ldquo;../OUT_ptdist_attrib/&rdquo;. The third argument, <code>0</code>, specifies that the first geometry instance should be used.</li><li><code>"ptdist"</code> is the name of the attribute being accessed using the <code>detail()</code> function. It refers to the attribute called &ldquo;ptdist&rdquo; in the referenced geometry.</li><li><code>-</code> is the subtraction operator, which subtracts the value obtained from <code>detail("../OUT_ptdist_attrib/","ptdist",0)</code> from the next part of the expression.</li><li><code>ch()</code> function is used to retrieve the value of a channel parameter. In this case, it is accessing the channel parameter named &ldquo;board_thickness&rdquo; from the node located at the relative path &ldquo;../CONTROLLER/&rdquo;.</li><li><code>"../CONTROLLER/board_thickness"</code> specifies the relative path to the channel parameter named &ldquo;board_thickness&rdquo; in the referenced node.</li></ol><p>Putting it all together, the expression calculates the absolute difference between the value of the <code>ptdist</code> attribute from the referenced geometry and the value of the &ldquo;board_thickness&rdquo; channel parameter from the referenced node. The <code>abs()</code> function ensures that the result is positive.</p><p>Now we just need to copy the parameter <code>board thickness</code> from the <code>CONTROLLER</code> into the <code>X</code> component of the origin vector on the line.</p><p><img src=/notes/attachments/hou-bookshelf-line-origin-position.png width=auto></p><p>What this does is shifts the line over based on the thickness of the boards and shrinks it so that there are no intersections.</p><blockquote class=important-callout><p>This will be important if we want to destroy the bookshelf.</p></blockquote><a href=#loops><h3 id=loops><span class=hanchor arialabel=Anchor># </span>Loops</h3></a><p>Next we will use <em>loops</em> in the <strong>SOP</strong> network.</p><p><img src=/notes/attachments/houdini_bookshelf_shelves_loop.png width=auto></p><p>The reason we are going to a loop here is simple. We need to delete first and last point of each shelf line. This is to remove to the top and bottom lines because those are already accounted for in the rest of the network.</p><p>We can drop down a <em>for each connected piece</em> loop preset. This will setup a <em>connectivity</em> node which adds a <em>class</em> attribute to each separate piece. We can then loop through each of those separately.</p><blockquote class=important-callout><p>The reason we use a loop is to easily solve the the <em>first and last</em> in each line. This is because we are going to use the <em>point numbers</em> to target the first and last in a <em>wrangle</em>.</p></blockquote><p>Before we get to the loops though we need to drop down a <em>copy to points</em>. This will copy the lines we will use for the shelves.</p><p><img src=/notes/attachments/houdini_bookshelf_connect_to_shelves_91.png width=auto></p><p>Below is sort of what the lines should look like (depending on your parameters)</p><p><img src=/notes/attachments/houdini_bookshelf_vertical_lines.png width=auto></p><p>After the <em>copy to points</em> drop down a <em>resample</em> node.</p><p><img src=/notes/attachments/houdini_bookshelf_ctp_resample_shelves.png width=auto></p><p>The resample node will determine the amount of shelves in our bookshelf.</p><p>In the <em>resample</em> we&rsquo;ll then copy the <code>shelf_distance</code> to length.</p><p><img src=/notes/attachments/houdini_bookshelf_shelf_distance.png width=auto></p><p>Now your lines should look similar to this:</p><p><img src=/notes/attachments/houdini_bookshelf_vertical_lines_numbers.png width=auto></p><p>Pay attention to the numbers here. As explained before we will have to use this information to solve a problem.</p><p>Now is where we get into loops.</p><p>Loops are pervasive in programming, in houdini we can use loops on the SOP level to loop through elements of the geometry or simply sumbers.</p><p>Drop down a <em>loop through connected pieces</em> loop preset. This will create a set of nodes that will loop through separate pieces of a mesh.</p><p><img src=/notes/attachments/houdini_bookshelf_loop_through_pieces.png width=auto></p><p>Next put an <em>attribute wrangle</em> inside the loop and add the following code to it.</p><blockquote class=important-callout><p>Make sure you are running over points</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>npts</span> <span class=o>=</span> <span class=n>npoints</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>//npoints is the total number of points in the geo stream
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>removepoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>npts</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>removepoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>If you turn on <em>single pass</em> in the foreach loop we can see what&rsquo;s going on. Each line now has point numbers that start at 0.</p><p><img src=/notes/attachments/houdini_bookshelf_vertical_point_numbers.png width=auto></p><p>After the wrangle it looks like this:</p><p><img src=/notes/attachments/houdini_bookshelf_remove_first_and_last.png width=auto></p><p>Now we take the horizontal lines and copy those to these points.</p><p><img src=/notes/attachments/houdini_bookshelf_copy_horizontal_lines.png width=auto></p><p>It should look similar to this now:</p><p><img src=/notes/attachments/houdini_bookshelf_horizontal_lines_shelves.png width=auto></p><p>Now we do the same thing we did for the rest of the boards. We use a <em>sweep</em> and <em>polyextrude</em> node.</p><p><img src=/notes/attachments/houdini_bookshelf_sweep_extrude_shelves.png width=auto></p><p>In the sweep node copy in the <code>depth</code> parameter from the controller. Or whatever parameter you are using for the depth of the bookshelf.</p><p>Then in the <em>polyextrude</em> node copy in the <code>board thickness</code> parameter from the controller to the <code>Distance</code> parameter of the <em>polyextrude</em> node.</p><p>You should now see the following in the viewport:</p><p><img src=/notes/attachments/houdini_bookshelf_shelves_after_extrude.png width=auto></p><a href=#top-board><h2 id=top-board><span class=hanchor arialabel=Anchor># </span>Top Board</h2></a><p>Remember we removed the top and bottom boards. Now we need to add them back in.</p><p>We will do this in a similar way.</p><p><img src=/notes/attachments/houdini_bookshelf_top_board_ctp.png width=auto></p><p>Next we need to plug in the horizontal and vertical lines into this <em>copy to points</em>. It should look like the following:</p><p><img src=/notes/attachments/houdini_bookshelf_ctp_top_shelf_lines.png width=auto></p><p>Next we need to drop down another <em>Loop through connected pieces</em>, just like before.</p><p>Now put an <em>attribute wrangle</em> down inside the loop. This time all we need to do is remove the first point. We can do so with one line:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>removepoint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Now after the loop drop down a <em>transform</em> node.</p><p>In the <code>Y</code> section of the transform copy the <code>Board Thickness</code> parameter and add a <code>-</code> to the front.</p><p>This will offset the lines by the board thickness in the <code>Y</code> direction.</p><p>Next add the sweep and poly bevel nodes like before.</p><blockquote class=important-callout><p>You can copy them from the other setup because the references are going to be the exact same here.</p></blockquote><a href=#combine-components><h1 id=combine-components><span class=hanchor arialabel=Anchor># </span>Combine components</h1></a><p>Now we can combine all the components.</p><p>Drop down a <code>merge</code> node and pipe in all the <code>OUTs</code> from each component into it.</p><p>It should look like the following:</p><p><img src=/notes/attachments/houdini_bookshelf_combined_components.png width=auto></p><a href=#uvs><h1 id=uvs><span class=hanchor arialabel=Anchor># </span>UVs</h1></a><p>Let&rsquo;s tackle procedural UVs. This can be an extremely complex topic, we are going to keep it as simple as we can to make doing it procedurally worthwhile for us.</p><a href=#defining-the-problem-for-uvs><h2 id=defining-the-problem-for-uvs><span class=hanchor arialabel=Anchor># </span>Defining the problem for UVs</h2></a><p>In procedural systems where the geometry changes and we want textures or surface coordinates we need our UV system to be procedural as well.</p><p>To accomplish this we will start with a simple solution.</p><blockquote class=note-callout><p>Procedural UVs can be tricky and computationally intensive.</p></blockquote><a href=#setting-up-initial-uvs><h2 id=setting-up-initial-uvs><span class=hanchor arialabel=Anchor># </span>Setting up initial UVs</h2></a><p>Now in each of the blocks we&rsquo;ve created for all our components we will need to add a section for UVs.</p><p>First let&rsquo;s add a UV section to our controller. In that section let&rsquo;s add a <code>toggle</code> parameter and name it <code>bypass UVs</code>.</p><p>Now, in each of the component sections add the following after the <code>polyextrude</code> nodes.</p><ol><li><code>uvautoseam</code></li><li><code>uvflatten</code></li><li><code>switch</code></li></ol><p>Hook the <code>switch</code> node up to bypass the UV nodes.</p><p><img src=/notes/attachments/houdini_bookshelf_UV_switch.png width=auto></p><p>copy the <code>bypass UVs</code> parameter into the <code>switch</code> node. This will allow us to bypass the UVs while we are just working on the geometry.</p><blockquote class=tip-callout><p>You can split the 3D viewport by using the white square drop-down in the top right.</p><p><img src=/notes/attachments/houdini_split_3d_viewport.png width=auto></p></blockquote><p>Your UVs should look something like this:</p><p><img src=/notes/attachments/houdini_bookshelf_UV_example_01.png width=auto></p><a href=#fixing-uvs-for-vertical-boards><h3 id=fixing-uvs-for-vertical-boards><span class=hanchor arialabel=Anchor># </span>Fixing UVs for vertical boards</h3></a><p>Once you have copied this setup to the other components you&rsquo;ll probably notice that the UVs for the vertical boards are not consistent. They are too long and force the rest of the UVs to be too small or are not the correct <a class="internal-link broken">texel density</a>.</p><p>In order to fix this we need to add <em>edge loops</em> to our geometry. This will allow us to cut the UVs so they fit in our UV space better.</p><p>To do this we need to add a resample node after the <code>OUT_vert_line</code> and before the <code>inner</code> and <code>outer</code> vertical boards.</p><p><img src=/notes/attachments/houdini_bookshelf_resaple_vertical_boards.png width=auto></p><p>Let&rsquo;s add another parameter to our <code>CONTROLLER</code>. Add a float called <code>vertical_board_UV_split</code> to the UV section we created.</p><p>Copy that parameter into the <code>distance</code> of the new <code>resample</code> node we created.</p><blockquote class=note-callout><p>We are using a resample here because the <code>sweep</code> node will create segments at each point. It&rsquo;s easier doing it this way than adding edge loops after the fact.</p></blockquote><p>Now add a <code>group</code> node after the <code>polyextrude</code>. It should look like this:</p><p><img src=/notes/attachments/houdini_bookshelf_vertical_seams_group.png width=auto></p><p>This will allow us to select those <em>edge loops</em>. In the group node uncheck everything but <code>include by edges</code> and then only have <code>max edge angle</code> checked on. and set it to 20</p><p><img src=/notes/attachments/houdini_bookshelf_group_select_edge_loops.png width=auto></p><p>Name the group <code>seams</code>.</p><p>Now the UV nodes and the switch should be copied over after this group node.</p><p><img src=/notes/attachments/houdini_bookshelf_seams_uv_nodes.png width=auto></p><p>In the <code>uvautoseam</code> we need to tell it to use the group we just created as <em>seams</em> to cut the UVs.</p><p><img src=/notes/attachments/houdini_bookshelf_use_seam_group.png width=auto></p><p>Add the <code>seams</code> group to the <code>include edges</code> parameter of the <code>uvautoseam</code>.</p><p>Then add the <code>seams</code> group to the <code>uvflatten</code> node under the <code>Flattening Constraints</code> and in the <code>seams</code> parameter:</p><p><img src=/notes/attachments/houdini_bookshelf_seams_uvflatten_group.png width=auto></p><p>Now you should have something like the following:</p><p><img src=/notes/attachments/houdini_bookshelf_3d_uv_vertical_boards.png width=auto></p><p>We can see the cuts here working as expected and unwrapping the geometry.</p><p>But we have overlapping UVs. We need to add the <code>seams</code> group to another parameter in the <code>uvflatten</code> node.</p><p><img src=/notes/attachments/houdini_bookshelf_layout_seams_uvflatten.png width=auto></p><p>Add <code>seams</code> under the <code>layout constraints</code> section in the <code>seams</code> parameter.</p><p>Now our UVs should look like this:</p><p><img src=/notes/attachments/houdini_bookshelf_uvs_layout_seams.png width=auto></p><a href=#uv-layout><h2 id=uv-layout><span class=hanchor arialabel=Anchor># </span>UV layout</h2></a><p>We now want to layout the UVs a bit better. we can do this with a <code>uvlayout</code> node. Let&rsquo;s drop one after the <code>uvflatten</code> node.</p><p><img src=/notes/attachments/houdini_bookshelf_uvlayout_after_flatten.png width=auto></p><p>Next let&rsquo;s add a <code>toggle</code> to our <code>CONTROLLER</code> in the UV section called <code>Stack_UVs</code>. We will use this to toggle the <code>stack identical islands</code> parameter on the <code>uvlayout</code> node.</p><a href=#align-uvs><h3 id=align-uvs><span class=hanchor arialabel=Anchor># </span>Align UVs</h3></a><p>In order to align our UVs we need to do some tricky things. We will need to loop through our UV islands.</p><p>We are also going to add another switch to bypass the aligning loop as this can be computationally intense.</p><p>You&rsquo;re setup should look something like this:</p><p><img src=/notes/attachments/houdini_bookshelf_uv_align_loop_start.png width=auto></p><p>In the new group node we need to select the vertical edges:</p><p><img src=/notes/attachments/houdini_bookshelf_group_select_vertical_edges.png width=auto></p><p>set the group name to <code>align</code>.</p><p>Then enable <code>include by edges</code> and use the <code>min</code> and <code>max</code> edge angles until you select the vertical edges.</p><p><img src=/notes/attachments/houdini_bookshelf_selected_vertical_edges.png width=auto></p><p>We will use these to align and rotate our UVs in the same direction.</p><blockquote class=note-callout><p>This alignment will help us for texturing, maybe we want it to be a wood bookshelf and we want the grains to all be in the correct direction.</p></blockquote><p>Now let&rsquo;s setup the loop to run over our UVs.</p><p>in the <code>connectivity</code> node set it <code>primitive</code> and the attribute type to <code>integer</code> then toggle on the <code>use UV connectivity</code> and make sure the uv attribute is <code>uv</code></p><p><img src=/notes/attachments/houdini_bookshelf_connectivity_uvs.png width=auto></p><p>Now we need to add another <code>uvflatten</code> node, but this time inside the loop.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/notes/3D-Modeling/Houdini/Houdini-Hub/ data-ctx="Houdini Procedural Bookshelf Tutorial" data-src=/notes/3D-Modeling/Houdini/Houdini-Hub class=internal-link>Houdini Hub</a></li><li><a href=/notes/3D-Modeling/Houdini/lessons/Houdini-Procedural-Modeling-Fundimentals/ data-ctx="Houdini Procedural Bookshelf Tutorial" data-src=/notes/3D-Modeling/Houdini/lessons/Houdini-Procedural-Modeling-Fundimentals class=internal-link>Houdini Procedural Modeling Fundimentals</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://notes.benshurts.com/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Ben Shurts using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://notes.benshurts.com/>Home</a></li><li><a href=https://twitter.com/artofbenshurts>Twitter</a></li><li><a href=https://github.com/benshurts>Github</a></li></ul></footer></div></div></body></html>