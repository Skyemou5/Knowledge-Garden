<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Spherical Coordinates Beside points, vector, normals and matrices the last useful technique from linear algebra we will need to render images is to express vectors in terms of spherical coordinates."><title>{{title}}</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://notes.benshurts.com//icon.png><link href=https://notes.benshurts.com/styles.708c2658f93e3a9d323a1f9fded8f4b2.min.css rel=stylesheet><link href=https://notes.benshurts.com/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://notes.benshurts.com/js/darkmode.7f1fd235efdec6a4bdcb4d8d99113082.min.js></script>
<script src=https://notes.benshurts.com/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://notes.benshurts.com/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://notes.benshurts.com/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://notes.benshurts.com/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://notes.benshurts.com/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://notes.benshurts.com/",fetchData=Promise.all([fetch("https://notes.benshurts.com/indices/linkIndex.90c56e84942c5c795fb01cde3e94cdb0.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://notes.benshurts.com/indices/contentIndex.75b74f9284ebcc0678e51ef3ce5c25c8.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://notes.benshurts.com",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://notes.benshurts.com",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/notes.benshurts.com\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://notes.benshurts.com/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://notes.benshurts.com/>Knowledge Garden</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>{{title}}</h1><p class=meta>Last updated
Oct 27, 2022
<a href=https://github.com/benshurts/Knowledge-Garden/notes/3D-Modeling/blender/Sources/Scratchpixel/Spherical%20Coordinated%20-%20scratchpixel.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#trigonometric-functions>Trigonometric Functions</a></li><li><a href=#representing-vectors-with-spherical-coordinates>Representing Vectors with Spherical Coordinates</a></li><li><a href=#conventions-again-z-is-up>Conventions Again: Z is Up!</a></li><li><a href=#converting-cartesian-to-spherical-coordinates>Converting Cartesian to Spherical Coordinates</a></li><li><a href=#and-vice-versa-spherical-coordinates-to-cartesian-coordinates>And Vice Versa: Spherical Coordinates to Cartesian Coordinates</a></li><li><a href=#more-tricks-with-trigonometric-functions>More Tricks with Trigonometric Functions</a><ol><li><a href=#computing-cosϕ>Computing cos(ϕ)</a></li></ol></li></ol></nav></details></aside><a href=#spherical-coordinates><h1 id=spherical-coordinates><span class=hanchor arialabel=Anchor># </span>Spherical Coordinates</h1></a><p>Beside points, vector, normals and matrices the last useful technique from linear algebra we will need to render images is to express vectors in terms of spherical coordinates. We could certainly render images wihout using them, but you will see that using them simplifies many problems especially when it comes to shading. This chapter is also a good opportunity to review trigonometric functions.</p><a href=#trigonometric-functions><h2 id=trigonometric-functions><span class=hanchor arialabel=Anchor># </span>Trigonometric Functions</h2></a><p><img src=https://www.scratchapixel.com/images/upload/geometry/trigonometry.png? width=auto alt></p><p>Figure 1: the sine and cosine function can be used to find the coodinate of P which lies on the unit circle.</p><p>Rendering a computer generated images is almost entirely a geometric problem so not understanding or using trigonometry for creating such images (and the phythagorean theorem) would be very hard. Let&rsquo;s start to review the <strong>sine</strong> and <strong>cosine</strong> function as well as the way angles can be computed from 2D coordinates. Usually these functions are defined in regards to the <strong>unit circle</strong> (a circle of radius 1). When we draw a point P on this unite circle, the x-coordinate of the point can be computed using the cosine of the angle subtended by the x-axis and a line that goes from the origin of the coordinate system to P. This angle is usually called θ</p><p>(the greek letter theta). Similarly, the sine of this angle gives the y-coordinate of the point P. Note that the angle θ is defined in <strong>radians</strong>. It will be easier to defined the angles in degrees, but we will need to convert them internally to radians to use them in the C++ trigonometric functions: θradians=π180θdegrees. Remember that a complete turn around the unit circle represents 360 degrees of 2π</p><p>.</p><p><img src=https://www.scratchapixel.com/images/upload/geometry/triangle.png? width=auto alt></p><p>Figure 2: names given to the side of a right-triangle</p><p>It is also important to remember that the cosine, sine and tangent functions are defined from a simple relationship between the edges of a right triangle (right-angled triangle). The tangent formula is interesting because to come back to our example using the unit circle, you can see that it can be computed using the ratio of y over x. Another very useful function in Computer Graphics is the <strong>arctangent</strong> which is the tangent inverse function. In other words, if you feed the arctangent function with the result of the tangent function you get θ</p><p>. In programming you can use the atan function but this function doesn&rsquo;t take the sign of the parameters x and y into account. For instance if P has coordinates (0.707, 0.707) the angle θ is π/4. If the coordinates of P are now (-0.707, -0.707) theta should then be 3π/4. But the tan function will compute the ratio -0.0707/-0.0707 which is 1; the result of the tan function for such coordinates will thus be π/4</p><p>though this is the angle for the point with coordinates (0.707, 0.707) and not (-0.707, -0.707). This is obviously wrong. To fix the issue, you need to use the C/C++ function atan2 instead which takes into account the sign of the point&rsquo;s coordinates in the computation of the angle (check the documentation on the function for further details). Similarly to atan2, you can compute the inverse function of sine and cosine using arcsine (sin in C++) and arccosine (acts). Let&rsquo;s summarise all the functions we have talked about so far:</p><p>$$\begin{array}{l}
\sin(\theta)={\text{opposite side} \over \text{hypothenuse}}\\ \cos(\theta)={\text{adjacent side} \over \text{hypothenuse}}\\ \tan(\theta)={\text{opposite side} \over \text{adjacent side}}
\end{array}$$</p><p>$$\begin{array}{l}
\theta = \text{acos}(P_x)\\ \theta = \text{asin}(P_y)\\ \theta = \text{atan2}(P_y, P_x)
\end{array}$$</p><p>Refer to the documentation of these functions to learn what they exactly return. The interesting thing to note is that the angle returned by the atan2 function is positive for counter-clockwise angles (upper half-plane, y > 0) and negative for clockwise angles (lower half-plane, y &lt; 0). It produces results in the range [−π,π]</p><p>. Finally let&rsquo;s finish this quick reminder with the Pythagorean Theorem which we will also be using often (for example the ray-sphere intersection test which you can find explained in the
<a href=http://localhost/lessons/3d-basic-rendering rel=noopener>Foundations of 3D Rendering</a> section). It says that:</p><p>$hypothenuse2=adjacent2+opposite2$</p><p>In other words, the square of the hypothenuse length is equal to the sum of the squares of the other two sides of the right triangle (adjacent and opposite).</p><a href=#representing-vectors-with-spherical-coordinates><h2 id=representing-vectors-with-spherical-coordinates><span class=hanchor arialabel=Anchor># </span>Representing Vectors with Spherical Coordinates</h2></a><p><img src=https://www.scratchapixel.com/images/upload/geometry/sphericalcoord.png? width=auto alt></p><p>Figure 3: a vector can also be represented by two angles: the vertical angle (in red) θ</p><p>and the horizontal angle (in green) ϕ</p><p>.</p><p><img src=https://www.scratchapixel.com/images/upload/geometry/sphericalcoord1.png? width=auto alt></p><p>Figure 4: in the top figure, we are looking perpendicularly to the plane defined by the vector and the up axis. In the bottom figure, we are looking at the vector from the top. The angle θ</p><p>(top figure) can vary from 0 to π and the angle ϕ (bottom figure) can vary from 0 to 2π.</p><p>So far we have learned how to represent vectors (as in directions) using cartesian coordinates (with three values, one for each axis). It is also possible though to represent the same vectors with only two values. One to represent the angle between the vector and the vertical axis and one to represent the angle between the the vector projected onto the horizontal plane and the right vector from the Cartesian coordinate system. In figure 3, these angles are represented in red and green. The vertical angle is always called θ</p><p>(the greek letter theta) and the horizontal angle (in green) is always called ϕ (the greek letter phi). No matter what you do and what you see in text books, we advise you to follow these rules which is about the only convention unanimously followed by the CG community. These angles should be expressed in radians. Note that θ lies within the range [0:π] while ϕ varies in the range [0:2π] (see figure 4). As such θ and ϕ can also be seen as coordinates and are called <strong>sphercal coordinates</strong>. In figure 4 we can see what the vector looks like in 2D view. On top, we are looking perpendiculary to the plane defined by the vector and the up axis. The bottom figure represents a view from the top. Vr Vu and Vf correspond to the cartesian coordinates of the vector in the Cartesian coordinates systems defined by the right, up and forward axes. Note that we haven&rsquo;t used the names x, y, z for the axis for a reason we will explain soon. Also, we have always represented a normalized vector (of unit length) but any vectors of arbitrary length can be represented using spherical coordinates. The formal definition of spherical coordinates includes an additional term (usually denoted r for radial distance) to represent the length of the vector combined with θ and ϕ</p><p>which can also be called the <strong>polar</strong> and <strong>azimuth</strong> angles. Spherical coordinates are just another way of enconding vectors. They make this representation compact as only two numbers are used instead of three (if you don&rsquo;t care about the length of the vector) with the Cartesian coordinates (it can save memory in your program) and they will become most useful when we will talk about shading. The question now is how we convert a vector represented in Cartesian coordinates to spherical coordinates.</p><a href=#conventions-again-z-is-up><h2 id=conventions-again-z-is-up><span class=hanchor arialabel=Anchor># </span>Conventions Again: Z is Up!</h2></a><p><img src=https://www.scratchapixel.com/images/upload/geometry/sphericalcoord3.png? width=auto alt></p><p>Figure 5: in mathematics and physics, spherical coordinates are represented in a Cartesian coordinate system where the z-axis represents the up vector.</p><p>The convention when it comes to represent vectors in mathematics and physics is to name the up vector as the z-axis and the right and forward vector respectively the x- and y-axis. And to make things easier, the convention is also to use a <strong>left-hand coordinate</strong> system (which you can see in figure 5). If you read an article on spherical coordinates from a reliable wiki, it&rsquo;s very likely that it will use this convention. Having z-axis representing the up vector, is something we have already briefly mentioned in the chapter on
<a href=http://localhost/lessons/mathematics-physics-for-computer-graphics/geometry/coordinate-systems rel=noopener>Coordinate System</a>. As you can see, this convention is different from the one we normally use (where the up axis is the y-axis) but unfortunatly this notation is the norm and we will have to stick to it. What is actually the main point of interest to us, is how this will affect our code. When we will study shading, you will see that we use a trick to convert the vectors from world space to a local coordinate system where the normal at the surface of the shaded point represent the up vector (see the next chapter
<a href=http://localhost/lessons/mathematics-physics-for-computer-graphics/geometry/creating-an-orientation-matrix-or-local-coordinate-system rel=noopener>Creating an Orientation Matrix or Local Coordinate System</a>). However rather than building the matrix to transform vector from whatever space they are in to this local coordinate system by copying the tangent (x-axis), the normal (y-axis) and the bi-tangent (z-axis) to the first (right vector), second (up vector) and third (forward vector) row of the matrix as we usually do, we will copy them in them in this order:</p><p>$$\begin{bmatrix}T_x&T_y&T_z&0\B_x&B_y&B_z&0\N_x&N_y&N_z&0\0&0&0&1\end{bmatrix}$$</p><p>Where T, B and N represent the tangent bi-tangent and normal vectors. Note that we swapped the position of the normal (up vector or y-axis in the conventional coordinate system) and the bitangent (forward vector or z-axis in the conventional coordinate system) in the matrix construction. Let&rsquo;s see how this work. Imagine you have a normal whose coordinates in world space are (0, 1, 0). In other words, it points straight up. Let&rsquo;s construct a matrix using the trick we have just learned where the tangent and bit agent vectors have the coordinates (1, 0, 0) and (0, 0, 1):</p><p>$$\begin{bmatrix}1&0&0&0\0&0&1&0\0&1&0&0\0&0&0&1\end{bmatrix}$$</p><p>Now imagine you want to transform a vector v</p><p>in the local frame represented by this matrix and that the coordinates of this vector are (0, 1, 0). It is parallel to the y-axis in world space. If we apply the matrix-vector multiplication formula we get:</p><p>$${ \begin{array}{l}
x = Vx * M_{00} + Vy * M_{10} + Vz * M_{20} = 0 * 1 + 1 * 0 + 0 * 0 = 0\\ y = Vx * M_{01} + Vy * M_{11} + Vz * M_{21} = 0 * 0 + 1 * 0 + 0 * 1 = 0\\ z = Vx * M_{02} + Vy * M_{12} + Vz * M_{22} = 0 * 0 + 1 * 1 + 0 * 0 = 1\end{array} }$$</p><p>As you can see, once transformed, the vector has coordinates (0, 0, 1). It is aligned with the up vector which is represented by the normal which is also in this special case the z-axis. We have successfully managed to convert a vector in a coordinate system where the z-axis is the up vector. This concept is confusing especially if you try to display the resulting vector in a 3D application where the y-axis is up and the z-axis is the forward axis. However the way you need to look at this, is really more like a swap of the y- and z-coordinates of the vector.</p><a href=#converting-cartesian-to-spherical-coordinates><h2 id=converting-cartesian-to-spherical-coordinates><span class=hanchor arialabel=Anchor># </span>Converting Cartesian to Spherical Coordinates</h2></a><p><img src=https://www.scratchapixel.com/images/upload/geometry/sphericalcoord4.png? width=auto alt></p><p>Figure 6: it is easier to see that Vz is equal to cos(θ)</p><p>when we rotate the figure by 90 degrees clockwise.</p><p>For the demonstration, we will assume that the vector is normalised. The illustration on the left in figure 6 is the same as the top illustration in figure 4 but with the up vector now represented as the z-axis (in blue). If we rotate the figure by 90 degrees clockwise (on the right of figure 6) you can see that it looks similar to figure 1 where the x-coordinates (in figure 1) was computed using the formula cos(θ). Applied to the case showed in figure 6, we can therefore say that Vz is equal to cos(θ) as well (here Vz is the same as Px in figure 1). And consequently the angle θ itself can be computed as the arccosine of the value Vz:</p><p>$$\begin{array}{l}V_z = \cos(\theta) \rightarrow \theta = acos(V_z)\end{array}$$</p><p>In C++ you will write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>theta</span> <span class=o>=</span> <span class=n>acos</span><span class=p>(</span><span class=n>Vz</span><span class=p>);</span>  
</span></span></code></pre></td></tr></table></div></div><p><img src=https://www.scratchapixel.com/images/upload/geometry/sphericalcoord5.png? width=auto alt></p><p>Figure 7: computing the angle ϕ.</p><p>Let&rsquo;s now find out how to compute the angle ϕ</p><p>. Let&rsquo;s now have a look at figure 7 which is the same at the illustration at the bottom of figure 4 but where the right and forward axis have now be named the x- and y-axis (in red and green). Remember from our quick trigonometric function refresher (at the top of this chapter), that the tangent of an angle can be computed by taking the ratio of the opposite side (which is Vy in this example) over the adjacent side (Vx) of a right triangle. You may ask why we just not compute this angle like we did for θ where we used the arccosine of the value Vx to find ϕ. That would actually be an option, but don&rsquo;t forget that ϕ varies from 0 to 2π. The advantage of using the tangent rather than the cosine is that the C++ implementation of the function (or rather the atan2 C++ function) will take into account the sign of its arguments (Vy and Vx) to return an angle that either varies from 0 to π if the vector is in the right part of the unit circle, and 0 to −π if the vector is in the left part of the unit circle. As a programmer, you will need to remap this value to the range [0:2π]</p><p>if necessary (look at the end of this lesson for the complete code):</p><p>$$tan(\phi)= { V_y \over V_x } \rightarrow \phi = atan({V_y \over V_x})$$</p><p>In C++ you will write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>phi</span> <span class=o>=</span> <span class=n>atan2</span><span class=p>(</span><span class=n>Vy</span><span class=p>,</span> <span class=n>Vx</span><span class=p>);</span>  
</span></span></code></pre></td></tr></table></div></div><a href=#and-vice-versa-spherical-coordinates-to-cartesian-coordinates><h2 id=and-vice-versa-spherical-coordinates-to-cartesian-coordinates><span class=hanchor arialabel=Anchor># </span>And Vice Versa: Spherical Coordinates to Cartesian Coordinates</h2></a><p>The formula to compute Cartesian coordinate back from spherical coordinates is actually straightforward:</p><p>$$\begin{array}{l}
x =\cos(\phi)\sin(\theta)\\ y=\sin(\phi)\sin(\theta)\\ z=\cos(\theta)
\end{array}$$</p><p>It is not always easy to remember this formula by heart, but it is always possible to re-write it from simple deductions. We know that the z coordinate of the vector only depends on the angle theta and that Vz=cos(θ). As for the x coordinate, imagine that you want V to have coordinates (1, 0, 0) which is true when θ=π/2 and ϕ=0. We know that sin(π/2)=1 and cos(0)=1 thus x=sin(θ)cos(ϕ). The same technique can be used to find y. Here some C++ code to compute cartesian coordinates from the two spherical angles:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>sphericalToCartesian</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>theta</span><span class=p>,</span> <span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>phi</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>cos</span><span class=p>(</span><span class=n>phi</span><span class=p>)</span> <span class=o>*</span> <span class=n>sin</span><span class=p>(</span><span class=n>theta</span><span class=p>),</span> <span class=n>sin</span><span class=p>(</span><span class=n>phi</span><span class=p>)</span> <span class=o>*</span> <span class=n>sin</span><span class=p>(</span><span class=n>theta</span><span class=p>),</span> <span class=n>cos</span><span class=p>(</span><span class=n>theta</span><span class=p>));</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div><a href=#more-tricks-with-trigonometric-functions><h2 id=more-tricks-with-trigonometric-functions><span class=hanchor arialabel=Anchor># </span>More Tricks with Trigonometric Functions</h2></a><p>Now that we have explained how to convert from cartesian coordinates to spherical and vice and versa, we will show a couple of useful functions that can be used in the renderer to manipulate vectors using both representations. The first function we will write is to compute θ from the cartesian coordinates. Remember than for spherical coordinates we will use a left-hand coordinate system in which the z-axis is the up vector. We have explained in this chapter than we can write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>sphericalTheta</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=nf>acos</span><span class=p>(</span><span class=n>clamp</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><p>Note that the input vector is supposed to be normalised so the vector&rsquo;s z-coordinates should be in the range [-1:1] but clamping this value is safer. Next we will write a function to compute ϕ. We have mentioned in this chapter before than the function atan returns a value in the range [−π:π]. We will need to remap this value in the range [0:2π].</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>sphericalPhi</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>p</span> <span class=o>=</span> <span class=n>atan2</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=p>(</span><span class=n>p</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>p</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=nl>M_PI</span> <span class=p>:</span> <span class=n>p</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><p>It is not always necessary to compute the angle values from the cartesian coordinates. Sometimes we just want to get the values for cos(θ), sin(θ), cos(ϕ) or sin(ϕ). Computing cos(θ) is really straightforward (it is very similar to the function sphericalTheta we wrote earlier):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kr>inline</span> <span class=n>T</span> <span class=n>cosTheta</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>w</span><span class=p>)</span> <span class=p>{</span> <span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>w</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span> <span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><p>Computing sin(θ) is a bit more complicated. We know that a vector lying on the unit circle has length 1 (unit length). We also know (Pythagorean theorem) that for such vector we can write V2x+V2y=1. If $Vx=cos(θ)$ and $Vy=sin(θ)$ we can write:</p><p>$$\cos(\theta)^2 + \sin(\theta)^2 = 1 \rightarrow \sin(\theta)^2=1-\cos(\theta)^2$$</p><p>We can first write a function that compute sin(θ)2 and then another one to compute sin(θ) which just returns the square root of the result return by the first function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>sinTheta2</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>w</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>T</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>cosTheta</span><span class=p>(</span><span class=n>w</span><span class=p>)</span> <span class=o>*</span> <span class=n>cosTheta</span><span class=p>(</span><span class=n>w</span><span class=p>));</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>sinTheta</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>w</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>sinTheta2</span><span class=p>(</span><span class=n>w</span><span class=p>));</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><p><img src=https://www.scratchapixel.com/images/upload/geometry/projectvec.gif? width=auto alt></p><p>Figure 8: the shadow of the yellow vector (v)</p><p>corresponds to the projection of (v) on the xy plane. This projected vector (vp) is shorter than a unit length vector but to normalize it, we can divide it xy coordinates by sin(θ) which we then can use to compute sin(ϕ) and cos(ϕ).</p><a href=#computing-cosϕ><h3 id=computing-cosϕ><span class=hanchor arialabel=Anchor># </span>Computing cos(ϕ)</h3></a><p>and sin(ϕ) is also slightly more complicated. As you can see in figure 8, even though the vector v is of unit length in world space, its shadow on the xy plane creates a vector which doesn&rsquo;t lie on the unit circle (unless θ=π/2). Technically speaking, the shadow of this vector corresponds to <strong>projecting</strong> the vector v on the xy plane. However using atan2 to compute ϕ only works for vector of unit length. You can also notice that the length of the vector v projected in the xy plane (vp), is directly related to the angle θ (figure 9). For values of θ close to 0 or π, vp is very small (example on the left in figure 8) and for values close to π/2, vp is longer (it lies on the unit circle when θ=π/2).</p><p><img src=https://www.scratchapixel.com/images/upload/geometry/projphi.png? width=auto alt></p><p>Figure 9. Left: the length of the vector vp</p><p>can be computed using sin(θ). Right: the x and y coordinates of the vector vp</p><p>once normalised can be used to compute phi (using atan2(y, x)).</p><p>The value sin(θ)</p><p>represents the length of the vector vp which is the vector v projected on the xy plane (figure 9a). Dividing the coordinates of vp by this length has for effect to normalise vp. Once a unit length vector, the x and y coordinates of vp can be used to compute sin(ϕ) and cos(ϕ).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>cosPhi</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>w</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>sintheta</span> <span class=o>=</span> <span class=n>sinTheta</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>if</span><span class=o>**</span> <span class=p>(</span><span class=n>sintheta</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=mi>1</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>clamp</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>w</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>/</span> <span class=n>sintheta</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>sinPhi</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>w</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>sintheta</span> <span class=o>=</span> <span class=n>sinTheta</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>if</span><span class=o>**</span> <span class=p>(</span><span class=n>sintheta</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=mi>0</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>clamp</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>w</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>/</span> <span class=n>sintheta</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><p><a href=https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry/matrix-operations rel=noopener>_arrow_back_Previous Chapter</a></p><p>Chapter 10 of 13</p><p><a href=https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry/creating-an-orientation-matrix-or-local-coordinate-system rel=noopener>Next Chapter</a></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/notes/3D-Modeling/blender/Sources/Scratchpixel/Scratchpixel-Home/ data-ctx="notes/3D-Modeling/blender/Sources/Scratchpixel/Spherical Coordinated - scratchpixel" data-src=/notes/3D-Modeling/blender/Sources/Scratchpixel/Scratchpixel-Home class=internal-link>{{title}}</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://notes.benshurts.com/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Ben Shurts using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://notes.benshurts.com/>Home</a></li><li><a href=https://twitter.com/artofbenshurts>Twitter</a></li><li><a href=https://github.com/benshurts>Github</a></li></ul></footer></div></div></body></html>