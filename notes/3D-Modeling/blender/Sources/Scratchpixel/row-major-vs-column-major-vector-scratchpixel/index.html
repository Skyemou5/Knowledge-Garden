<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="matrix math Earlier in this lesson, we have explained that vectors (or points) can be written down as [1x3] matrices (one row, three columns)."><title>{{title}}</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://notes.benshurts.com//icon.png><link href=https://notes.benshurts.com/styles.708c2658f93e3a9d323a1f9fded8f4b2.min.css rel=stylesheet><link href=https://notes.benshurts.com/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://notes.benshurts.com/js/darkmode.7f1fd235efdec6a4bdcb4d8d99113082.min.js></script>
<script src=https://notes.benshurts.com/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://notes.benshurts.com/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://notes.benshurts.com/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://notes.benshurts.com/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://notes.benshurts.com/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://notes.benshurts.com/",fetchData=Promise.all([fetch("https://notes.benshurts.com/indices/linkIndex.1fc9458db44c04724f37ec2338625bdc.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://notes.benshurts.com/indices/contentIndex.64226dbca25907f1c83ca052d0f7e75f.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://notes.benshurts.com",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://notes.benshurts.com",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/notes.benshurts.com\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://notes.benshurts.com/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://notes.benshurts.com/>Knowledge Garden</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>{{title}}</h1><p class=meta>Last updated
Oct 27, 2022
<a href=https://github.com/benshurts/Knowledge-Garden/notes/3D-Modeling/blender/Sources/Scratchpixel/row%20major%20vs%20column%20major%20vector%20-%20scratchpixel.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#row-major-order>Row-major order</a></li><li><a href=#column-major-order>Column-major order</a></li><li><a href=#row-major-order-1>Row-major order</a></li><li><a href=#column-major-order-1>Column-major order</a></li></ol></li><li><a href=#implication-in-coding-does-it-impact-performance>Implication in Coding: Does it Impact Performance?</a></li><li><a href=#row-major-and-column-major-order-in-computing>Row-major and Column-Major Order in Computing</a></li><li><a href=#summary>Summary</a><ol><li><a href=#row-major-vector-mathematics>Row-major vector (Mathematics)</a></li><li><a href=#column-major-vector-mathematics>Column-major vector (Mathematics)</a></li><li><a href=#row-major-matrix-computing>Row-major matrix (Computing)</a></li><li><a href=#column-major-matrix-computing>Column-major matrix (Computing)</a></li></ol></li></ol></nav></details></aside><a href=#matrix-math><h1 id=matrix-math><span class=hanchor arialabel=Anchor># </span>matrix math</h1></a><p>Earlier in this lesson, we have explained that vectors (or points) can be written down as [1x3] matrices (one row, three columns). Note however that we could have also written them down as [3x1] matrices (three rows, one column). Technically, these two ways of expressing points and vectors as matrices are perfectly valid and choosing one mode or the other is just a matter of convention.</p><p>Vector written as [1x3] matrix:$$V=\begin{bmatrix}x & y & z\end{bmatrix}$$</p><p>Vector written as [3x1] matrix: $$V=\begin{bmatrix}x\y\z\end{bmatrix}$$</p><p>In the first example ([1x3] matrix) we have expressed our vector or point in what we call the <strong>row-major order</strong>: the vector (or point) is written as a row of three numbers. In the second example, we say that that points or vectors are written in <strong>column-major order</strong>: we write the three coordinates of the vector or point vertically, as a column.</p><p>Remember that we express points and vectors as matrices to multiply them by [3x3] transformation matrices (for the sake of simplicity we will work with [3x3] rather than [4x4] matrices). We have also learned that we can only multiply matrices when the number of columns from the left matrix and the number of rows from the right matrix are the same. In other words the matrices [m x p] and [p x n] can be multiplied with each other but the matrices [p x m] and [p x n] can&rsquo;t. Note that if we write a vector as a [1x3] matrix we can multiply it by a [3x3] matrix (assuming this [3x3] matrix is on the right inside of the multiplication), but if we write this vector as a [3x1] matrix then we can&rsquo;t multiply it by a [3x3] matrix. This is illustrated in the following examples. The inner dimensions (3 and 3) of the matrices involved in the multiplication are the same (in green) so this multiplication is valid (and the result is a transformed point written in the form of a [1x3] matrix):</p><p>$$[1 \times \color{\green}{3}]*[\color{\green}{3} \times 3] = \begin{bmatrix}x & y & z\end{bmatrix} * \begin{bmatrix}
c_{00}&c_{01}&{c_{02}}\\ c_{10}&c_{11}&{c_{12}}\\ c_{20}&c_{21}&{c_{22}}\\ \end{bmatrix} =\begin{bmatrix}x&rsquo;&y&rsquo;&z&rsquo;\end{bmatrix}$$</p><p>The inner dimensions (1 and 3) of the matrices involved in the multiplication are not the same (in red) so this multiplication is not possible:</p><p>$$3 \times \color{\red}{1}]*[\color{\red}{3} \times 3] \rightarrow \begin{bmatrix}x\\ y\z\end{bmatrix} * \begin{bmatrix} c_{00}&c_{01}&{c_{02}}\\ c_{10}&c_{11}&{c_{12}}\\ c_{20}&c_{21}&{c_{22}}\\ \end{bmatrix}$$</p><p>So what do we do? The solution to this problem is not to multiply the vector or the point by the matrix, but the matrix M by the vector V. In other words, we move the point or vector to the right inside of the multiplication:</p><p>[$$[{3} \times \color{\green}{3}]*[\color{\green}{3} \times {1}] \rightarrow \begin{bmatrix} c_{00}&c_{01}&{c_{02}}\\ c_{10}&c_{11}&{c_{12}}\\ c_{20}&c_{21}&{c_{22}}\\ \end{bmatrix} * \begin{bmatrix}x\y\z\end{bmatrix} = \begin{bmatrix}x&rsquo;\y&rsquo;\z&rsquo;\end{bmatrix}$$</p><p>Note that the result of this operation is a transformed point written in the form of a [3x1] matrix. So we get a point to start with and we finish with a transformed point which is what we want. Problem solved. To summarize, when by convention we decide to express vectors or points in row-major order ([1x3]), we need to put the point on the left side of the multiplication and the [3x3] on the right inside of the multiplication sign. This is called in mathematics, a <strong>left</strong> or <strong>pre-multiplication</strong>. If you decide to write the vectors in column-major order instead ([3x1]), the [3x3] matrix needs to be on the left side of the multiplication and the vector or point on the right side. This is called a <strong>right</strong> or <strong>post-multiplication</strong>.</p><p>we need to be careful about how these terms are actually used. For instance Maya documentation says &ldquo;the matrices are post-multiplied in Maya. For example, to transform a point P from object-space to world-space (P&rsquo;) you would need to post-multiply by the worldMatrix. (P&rsquo; = P x WM)&rdquo;, which is confusing because it&rsquo;s actually a pre-multiplication but they are speaking about the position of the matrix with respect to the point in this particular case. That&rsquo;s actually an incorrect use of the terminology. It should have been written that in Maya, points and vectors are expressed as row-major vectors and that they are therefore pre-multiplied (meaning the point or vector appears before the matrix in the multiplication).</p><p>The following table summarizes the differences between the two conventions (where P, V and M respectively stands for Point, Vector and Matrix).</p><p>Row-major order</p><p>$$P/V=\begin{bmatrix}x & y & z\end{bmatrix}$$</p><p>Left or pre-multiplication</p><p>$P/V * M$</p><p>Column-major order</p><p>$$P/V=\begin{bmatrix}x \\ y \\ z\end{bmatrix}$$</p><p>Right or post-multiplication</p><p>$M * P/V$</p><p>Now that we have learned about these two conventions you might ask &ldquo;isn&rsquo;t that just about writing things on paper?&rdquo;. We know how to compute the product of two matrices A and B: multiply each coefficient within A&rsquo;s current row by the associated elements within B&rsquo;s current column and sum up the result. Lets apply this formula using the two conventions and lets compare the results:</p><a href=#row-major-order><h3 id=row-major-order><span class=hanchor arialabel=Anchor># </span>Row-major order</h3></a><p>$${ \begin{bmatrix}x & y & z\end{bmatrix} * \begin{bmatrix}
a & b & c \\ d & e & f \\ g & h & i
\end{bmatrix} }$$</p><p>$${ \begin{array}{l}x&rsquo; = x * a + y * d + z * g\y&rsquo; = x * b + y * e + z * h\z&rsquo; = x * c + y * f + z * i\end{array} }$$</p><a href=#column-major-order><h3 id=column-major-order><span class=hanchor arialabel=Anchor># </span>Column-major order</h3></a><p>$${ \begin{bmatrix}
a & b & c \\ d & e & f \\ g & h & i
\end{bmatrix} * \begin{bmatrix}x\y\z\end{bmatrix} }$$</p><p>$${\begin{array}{l}x&rsquo; = a * x + b * y + c * z\y&rsquo; = d * x + e * y + f * z\z&rsquo; = g * x + h * y + i * z\end{array} }$$</p><p>Multiplying a point or a vector by a matrix should give us the same result whether we use row- or column-major order. If you use a 3D application to rotate a point by a certain angle around the z-axis, you expect the point the be in certain position after the rotation no matter what internal convention the developer used to represent points and vectors. However as you can see from looking at the table above, multiplying a row-major and column-major point (or vector) by the same matrix clearly wouldn&rsquo;t give us the same result. To get back on our feet, we would actually need to <strong>transpose</strong> the [3x3] matrix used in the column-major multiplication to be sure that x&rsquo;, y&rsquo; and z&rsquo; are the same (if you need to remember what the transpose of a matrix is, check the chapter on
<a href=http://localhost/lessons/mathematics-physics-for-computer-graphics/geometry/matrix-operations rel=noopener>Matrix Operations</a>). Here is what we get:</p><a href=#row-major-order-1><h3 id=row-major-order-1><span class=hanchor arialabel=Anchor># </span>Row-major order</h3></a><p>$${ \begin{bmatrix}x & y & z\end{bmatrix} * \begin{bmatrix}
a & b & c \\ d & e & f \\ g & h & i
\end{bmatrix} }$$</p><p>$${\begin{array}{l}x&rsquo; = x * a + y * d + z * g\y&rsquo; = x * b + y * e + z * h\z&rsquo; = x * c + y * f + z * i\end{array} }$$</p><a href=#column-major-order-1><h3 id=column-major-order-1><span class=hanchor arialabel=Anchor># </span>Column-major order</h3></a><p>$${ \begin{bmatrix}
a & d & g \\ b & e & h \\ c & f & i
\end{bmatrix} * \begin{bmatrix}x\y\z\end{bmatrix} }$$</p><p>$${\begin{array}{l}x&rsquo; = a * x + d * y + g * z\y&rsquo; = b * x + e * y + h * z\z&rsquo; = c * x + f * y + i * z\end{array} }$$</p><p>In conclusion, going from row-major order to column-major order not only involves to swap the point or vector and the matrix in the multiplication but also to transpose the [3x3] matrix, to guarantee that both conventions give the same result (and vice versa).</p><p>From these observations, we can see that any series of transformations applied to a point or a vector when a row-major convention is used can be written in sequential order (or reading order). Imagine for instance that you want to translate point P with matrix T then rotate it around the z-axis with Rz then around the y-axis with Ry. You can write:</p><p>$P′=P∗T∗Rz∗Ry$</p><p>If you were to use a column-major notation you would need to call the transform in reverse order (which one might find counter-intuitive):</p><p>$P′=Ry∗Rz∗T∗P$</p><p>So you may think, &ldquo;there must be a reason to prefer one system to another&rdquo;. In fact, both conventions are correct and give us the same result, but for some technical reasons, Maths and Physics texts generally treat vectors as column vectors.</p><p>Order of transformation when we use colum-major matrices is more similar in mathematics to the way we write function evaluation and composition.</p><p>The row-major matrix convention however makes matrices easier to teach which is the reason we use it for Scratchapixel (as well as Maya, DirectX. They are also defined as the standard in the RenderMan specifications). However some 3D APIs such as OpenGL, use a column-major convention.</p><a href=#implication-in-coding-does-it-impact-performance><h2 id=implication-in-coding-does-it-impact-performance><span class=hanchor arialabel=Anchor># </span>Implication in Coding: Does it Impact Performance?</h2></a><p>There is another potentially very important aspect to take into consideration if you need to choose between row-major and column-major, but this has nothing to do really with the conventions themselves and how practical one is over the other. It has more to do with the computer and the way it works. Remember that we will be dealing with [4x4] matrices. Typically the implementation of a matrix in C++ looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=k>class</span><span class=err>** </span><span class=nc>Matrix44</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=p>...</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>m</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>4</span><span class=p>];</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div><p>As you can see the 16 coefficients of the [4x4] matrix are stored in a two-dimensional array of floats (or doubles depending on the precision you need. Our C++ Matrix class is a template). Which means that in memory the 16 coefficients will be laid out in the following manner: c00, c01, c02, c03, c10, c11, c12, c13, c20, c21, c22, c23, c30, c31, c32, c33. In other words, they are laid out contiguously in memory. Now lets see how these coefficients are accessed in a vector-matrix multiplication where vectors are written in row-major order:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// row-major order  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span><span class=err>&#39;</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>c00</span> <span class=o>+</span> <span class=n>y</span> <span class=o>*</span> <span class=n>c10</span> <span class=o>+</span> <span class=n>z</span> <span class=o>*</span> <span class=n>c20</span>  
</span></span><span class=line><span class=cl><span class=n>y</span><span class=err>&#39;</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>c01</span> <span class=o>+</span> <span class=n>y</span> <span class=o>*</span> <span class=n>c11</span> <span class=o>+</span> <span class=n>z</span> <span class=o>*</span> <span class=n>c21</span>  
</span></span><span class=line><span class=cl><span class=n>z</span><span class=err>&#39;</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>c02</span> <span class=o>+</span> <span class=n>y</span> <span class=o>*</span> <span class=n>c12</span> <span class=o>+</span> <span class=n>z</span> <span class=o>*</span> <span class=n>c22</span>  
</span></span></code></pre></td></tr></table></div></div><p>As you can see the elements of the matrix for x&rsquo; are not access sequentially. In other words to compute x&rsquo; we need the 1st, 5th and 9th float of the matrix 16 floats array. To compute y&rsquo; we need to access the 2nd, 6th and 10th float of this array. And finally for z&rsquo; we need the 3rd, 7th and 11th float from the array. In the world of computing, accessing elements from an array in a non-sequential order, is not necessarily a good thing. It actually potentially degrades the cache performance of the CPU. We won&rsquo;t go into too much details here, but lets just say that the closest memory that the CPU can access to is called a cache. This cache is very fast to access to but can only store a very limited number of data. When the CPU needs to access some data, it first check if it exists in the cache. If it does the CPU access this data right away (cache hit), but it doesn&rsquo;t (cache miss), it first needs to create an entry in the cache for it, then copy to this location the data from the main memory. This process is obviously more time consuming than when the data already exists in the cache so ideally we want to avoid cache misses as much as possible. Additionally to copying the particular data from main memory, the CPU also copies a chunk of the data that lives right next to it (for instance the next 24 bytes), because hardware engineers figured that if your code needed to access an element of an array for instance, it was likely to access the elements following it soon after. Indeed, in programs, we often loop over elements of an array in sequential order and this assumption is therefore likely to be true. Applied to our matrix problem, accessing the coefficients of the matrix in non sequential order can therefore be a problem. Assuming the CPU loads the requested float in the cache plus the 3 floats next to it, our current implementation might lead to many cache misses, since the coefficients used to compute x&rsquo; y&rsquo; and z&rsquo; are 5 floats apart in the array. On the other hand, if you use a column-major order notation, computing x&rsquo; for instance require to access the 1st, 2nd and 3rd elements of the matrix.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// column-major order  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span><span class=err>&#39;</span> <span class=o>=</span> <span class=n>c00</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>c01</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=n>c02</span> <span class=o>*</span> <span class=n>z</span>  
</span></span><span class=line><span class=cl><span class=n>y</span><span class=err>&#39;</span> <span class=o>=</span> <span class=n>c10</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>c11</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=n>c12</span> <span class=o>*</span> <span class=n>z</span>  
</span></span><span class=line><span class=cl><span class=n>z</span><span class=err>&#39;</span> <span class=o>=</span> <span class=n>c20</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>c21</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=n>c22</span> <span class=o>*</span> <span class=n>z</span>  
</span></span></code></pre></td></tr></table></div></div><p>The coefficients are accessed in sequential order which also means that we make a good use of the CPU cache mechanism (only 3 cache misses instead of 9 in our example). In conclusion we can say that from a programming point of view, implementing our point- or vector-matrix multiplication using a colum-major order convention might be better, performance wise, than the version using the row-major order convention. Practically though, we haven&rsquo;t been able to demonstrate that this was actually the case (when you compile your program using the optimisation flags -O, -O2 or -O3, the compiler can do the work for you by optimising loops over multi-dimensionals arrays) and we have been successfully using the row-major order version without any lose of performance compared to a version of the same code using a column-major order implementation.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=o>**</span><span class=k>class</span><span class=err>** </span><span class=nc>Vec3</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>public</span><span class=o>**:</span>  
</span></span><span class=line><span class=cl>	<span class=n>Vec3</span><span class=p>(</span><span class=n>T</span> <span class=n>xx</span><span class=p>,</span> <span class=n>T</span> <span class=n>yy</span><span class=p>,</span> <span class=n>T</span> <span class=n>zz</span><span class=p>)</span> <span class=o>:</span> <span class=n>x</span><span class=p>(</span><span class=n>xx</span><span class=p>),</span> <span class=n>y</span><span class=p>(</span><span class=n>yy</span><span class=p>),</span> <span class=n>z</span><span class=p>(</span><span class=n>zz</span><span class=p>)</span> <span class=p>{}</span>  
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>w</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl><span class=o>**</span><span class=k>class</span><span class=err>** </span><span class=nc>Matrix44</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>public</span><span class=o>**:</span>  
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>m</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>4</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>	<span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>multVecMatrix</span><span class=p>(</span><span class=o>**</span><span class=k>const</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>	<span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>ifdef</span> <span class=n>ROWMAJOR</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>2</span><span class=p>]);</span>  
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=k>else</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>Vec3</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>2</span><span class=p>]);</span>  
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>endif</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>include</span> <span class=o>&lt;</span><span class=n>cmath</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>include</span> <span class=o>&lt;</span><span class=n>cstdlib</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>include</span> <span class=o>&lt;</span><span class=n>cstdio</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>include</span> <span class=o>&lt;</span><span class=n>ctime</span><span class=o>&gt;</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=err>#</span><span class=n>define</span> <span class=n>MAX_ITER</span> <span class=mf>10e8</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=kt>int</span><span class=o>**</span> <span class=n>main</span><span class=p>(</span><span class=o>**</span><span class=kt>int</span><span class=o>**</span> <span class=n>argc</span><span class=p>,</span> <span class=o>**</span><span class=kt>char</span><span class=o>**</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>clock_t</span> <span class=n>start</span> <span class=o>=</span> <span class=n>clock</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>	<span class=n>Vec3</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=n>Matrix44</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>M</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=o>*</span><span class=n>tmp</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>M</span><span class=p>.</span><span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>for</span><span class=o>**</span> <span class=p>(</span><span class=o>**</span><span class=kt>int</span><span class=o>**</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>16</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=o>*</span><span class=p>(</span><span class=n>tmp</span> <span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=o>=</span> <span class=n>drand48</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>for</span><span class=o>**</span> <span class=p>(</span><span class=o>**</span><span class=kt>int</span><span class=o>**</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX_ITER</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>Vec3</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>vt</span> <span class=o>=</span> <span class=n>M</span><span class=p>.</span><span class=n>multVecMatrix</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Clock time %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>clock</span><span class=p>()</span> <span class=o>-</span> <span class=n>start</span><span class=p>)</span> <span class=o>/</span> <span class=kt>float</span><span class=p>(</span><span class=n>CLOCKS_PER_SEC</span><span class=p>));</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=mi>0</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><a href=#row-major-and-column-major-order-in-computing><h2 id=row-major-and-column-major-order-in-computing><span class=hanchor arialabel=Anchor># </span>Row-major and Column-Major Order in Computing</h2></a><p>For the sake of completeness, lets just mention as well, that terms row-major and column-major order can also be used in <strong>computing</strong> to describe the way elements of multidimensional arrays are laid out in memory. In row-major order, the elements of a multi-dimensional array are laid out one after the other, from the left to right, top to bottom. This is the method used by C/C++. For example the matrix:</p><p>$$M = \begin{bmatrix}1&2&3\4&5&6\end{bmatrix}$$</p><p>could be written in C/C++ as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span><span class=o>=</span><span class=p>{{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}};</span>  
</span></span></code></pre></td></tr></table></div></div><p>and the elements of this array would be laid out contiguously in linear memory as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1 2 3 4 5 6  
</span></span></code></pre></td></tr></table></div></div><p>In column-major order, which is used by languages such as FORTRAN and MATLAB, elements of the matrix are stored in memory from top to bottom, left to right. Using the same matrix example, the elements of the matrix would be stored (and accessed) in memory in the following way:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=mi>1</span> <span class=mi>4</span> <span class=mi>2</span> <span class=mi>5</span> <span class=mi>3</span> <span class=mi>6</span>  
</span></span></code></pre></td></tr></table></div></div><p>Knowing how the elements of a matrix are laid out in memory is important especially when you try to access them using pointer offset and for loop optimisation (we have explained previously in this chapter that it could affect the CPU cache performance). However since we will only be considering C/C++ as our programming language, column-major ordering (applied to computing) is of no great interest to us. We are only mentioning what the terms mean in computing, so that you are aware that they might describe two different things depending on the context in which they are used. You should be careful to not mix them up. In the context of mathematics, they describe whether you treat vectors (or points) as rows of coordinates or as columns and the second, and in the context of computing, they describe the way a certain programming language stores and accesses elements of multi-dimensional array (which matrices are) in memory.</p><p>OpenGL is an interesting case in that regard. When GL was initially created, the developers chose the row-major vector convention. Developers who extended OpenGL though thought they should go back to to column-major vector which they did. However for compatibility reasons, they didn&rsquo;t want to change the code for the point-matrix multiplication and decided instead to change the order in which the coefficients of the matrix were stored in memory. In other words OpenGL stores the coefficients in column-major order which means that the translation coefficients m03, m13 and m23 from a matrix using column-major vector have indices 13, 14, 15 in the float array as would the translation coefficients m30, m31 and m32 from a matrix using row-major vector.</p><a href=#summary><h2 id=summary><span class=hanchor arialabel=Anchor># </span>Summary</h2></a><p>The differences between the two conventions are summarised in the following table:</p><a href=#row-major-vector-mathematics><h3 id=row-major-vector-mathematics><span class=hanchor arialabel=Anchor># </span>Row-major vector (Mathematics)</h3></a><p>$$P/V=\begin{bmatrix}x & y & z\end{bmatrix}$$</p><p>Pre-multiplication $vM$</p><p>Call order and the order the transforms are applied is the same: &ldquo;take P, transform by T, transform by Rz, transform by Ry&rdquo; is written as $P′=P∗T∗Rz∗Ry$</p><p>API: Direct X, Maya</p><p>The rows of the matrix represent the bases (or axes) of a coordinate system (red: x-axis, green: y-axis, blue:z-axis)</p><p>$${\begin{bmatrix} \color{red}{c_{00}}& \color{red}{c_{01}}&\color{red}{c_{02}}&0\\ \color{green}{c_{10}}& \color{green}{c_{11}}&\color{green}{c_{12}}&0\\ \color{blue}{c_{20}}& \color{blue}{c_{21}}&\color{blue}{c_{22}}&0\0&0&0&1 \end{bmatrix} }$$</p><p>The translation values are stored in the c30, c31 and c32 elements.</p><p>$${\begin{bmatrix}
1&0&0&0\\ 0&1&0&0\\ 0&0&1&0\\ Tx&Ty&Tz&1\end{bmatrix} }$$</p><p>Transpose the matrix to use it as a column-major ordered matrix</p><a href=#column-major-vector-mathematics><h3 id=column-major-vector-mathematics><span class=hanchor arialabel=Anchor># </span>Column-major vector (Mathematics)</h3></a><p>$$P/V=\begin{bmatrix}x \\ y \\ z\end{bmatrix}$$</p><p>Post-multiplication $Mv$</p><p>Call order is the reverse of the order the transforms are applied: &ldquo;take P, transform by T, transform by Rz, transform by Ry&rdquo; is written as P′=Ry∗Rz∗T∗P</p><p>API: OpenGL, PBRT, Blender</p><p>The columns of the matrix represent the bases (or axes) of a coordinate system (red: x-axis, green: y-axis, blue:z-axis)</p><p>$${ \begin{bmatrix} \color{red}{c_{00}}& \color{green}{c_{01}}&\color{blue}{c_{02}}&0\\ \color{red}{c_{10}}& \color{green}{c_{11}}&\color{blue}{c_{12}}&0\\ \color{red}{c_{20}}& \color{green}{c_{21}}&\color{blue}{c_{22}}&0\0&0&0&1\end{bmatrix} }$$</p><p>The translation values are stored in the c03, c13 and c23 elements.</p><p>$${\begin{bmatrix}
1&0&0&Tx\\ 0&1&0&Ty\\ 0&0&1&Tz\\ 0&0&0&1\end{bmatrix} }$$</p><p>Transpose the matrix to use it as a row-major ordered matrix</p><a href=#row-major-matrix-computing><h3 id=row-major-matrix-computing><span class=hanchor arialabel=Anchor># </span>Row-major matrix (Computing)</h3></a><p>API: Direct X, Maya, PBRT</p><a href=#column-major-matrix-computing><h3 id=column-major-matrix-computing><span class=hanchor arialabel=Anchor># </span>Column-major matrix (Computing)</h3></a><p>API: OpenGL</p><hr><p>A reader posted a
<a href=http://stackoverflow.com/questions/17784791/4x4-matrix-pre-multiplication-vs-post-multiplication rel=noopener>question on Stackoverflow</a> suggesting the table above was confusing. The topic is confusing and despite our best attempt to shed some light on the matter, many people still get confused about it. We thought our answer on Stackoverflow could hopefully bring another insight on the question.</p><p>You have the theory (what you do in mathematics with a pen and paper) and what you do with your implementation (C++). These are two different problems.</p><p>Mathematics: you can use two notations, either column or row major. With row major vector, on paper, you need to write the vector-matrix multiplication vM where v is the row vector (1x4) and M your 4x4 matrix. Why? Because you can mathematically only write [1x4]*[4x4], and not the other way around. Similarly if you use column, then the vector needs to be written down vertically, or in notation [4x1] (4 rows, 1 column). Thus, the multiplication with a matrix can only be written as follows: [4x4][4x1]. Note that the matrix is put in front of the vector: Mv. The first notation is called a left or pre-multiplication (because the vector is on the left side of the product) and the second (Mv) is called a right or post-multiplication (because the vector is on the right side of the product). As you see the terms derive from whether the vector is on the left side (in front of, or &ldquo;pre&rdquo;) or on the right side (after, or &ldquo;post&rdquo;) of the matrix.</p><p>Now, if you need to transform a vector (or a point) then you need to pay attention to the order of multiplication, when you write them down on paper. If you want to translate something with matrix T and then rotate with R and then scale with S, then in a column major world, you need to to write v&rsquo; = S * R * T * v. In a row major world you need to write v&rsquo; = v * T * R * S.</p><p>That&rsquo;s for the theory. Let&rsquo;s call that the <strong>row/column vector convention</strong>.</p><p>Computer: then comes the point when you decide to implement this in C++ say. The good thing about this is that C++ doesn&rsquo;t impose you anything about anything. You can map the values of your matrix&rsquo;s coefficients in memory the way you want, and you can write the code to perform a matrix multiplication by another matrix the way you want. Similarly how you access the coefficients for a vector-matrix multiplication is completely up to you. You need to be make a clear distinction between how you map your coefficients in memory and what conventions you need to use from a mathematical point of you view to represent your vectors. These are two independent problems. Let&rsquo;s call this part the <strong>row/column-major layout</strong>.</p><p>For instance you can declare a matrix class as an array of say 16 contiguous floats. That&rsquo;s fine. Where coefficients m14, m24, m34 represent the translation part of the matrix (Tx, Ty, Tz), so you assume your &ldquo;convention&rdquo; is row-major even though you are told to use OpenGL matrix convention which is said to be column-major. Here the possible confusion comes from the fact that the mapping of the coefficients in memory is different from the mental representation you are making yourself of a &ldquo;column-major&rdquo; matrix. You code &ldquo;row&rdquo; but you were said to use (from a mathematical point of view) &ldquo;column&rdquo;, hence your difficulty to make sense of whether you do things right or wrong.</p><p>What&rsquo;s important is to see a matrix as a representation of a coordinate system defined by three axes, and a translation. Where and how you store this data in memory is completely up to you. Assuming the three vectors representing the three axes of the coordinate system are named AX(x,y,z), AY(x,y,z), AZ(x,y,z), and the translation vector is denoted by (Tx, Ty, Tz), then mathematically if you use column vector you have:</p><p>$$M = \begin{bmatrix} AXx & AYx & AZx & Tx\\ AXy & AYy & AZy & Ty \\ AXz & AYz & AZz & Tz \\ 0 & 0 & 1 & 1\end{bmatrix}$$</p><p>The axes of the coordinates system are written vertically. Now if you have if you use row-major:</p><p>$$M = \begin{bmatrix} AXx & AXy & AXz & 0\\ AYx & AYy & AYz & 0 \\ AZx & AZy & AZz & 0 \\ Tx & Ty & Tz & 1\end{bmatrix}$$</p><p>The axes of the coordinate system are written horizontally. So the problem now when it comes to computer world, is how to your store these coefficients in memory. You can as well do:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>m</span><span class=p>[</span><span class=mi>16</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl><span class=n>AXx</span><span class=p>,</span> <span class=n>AXy</span><span class=p>,</span> <span class=n>AXz</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=n>AYx</span><span class=p>,</span> <span class=n>AYy</span><span class=p>,</span> <span class=n>AYz</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=n>AZx</span><span class=p>,</span> <span class=n>AZy</span><span class=p>,</span> <span class=n>AZz</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=n>Tx</span><span class=p>,</span> <span class=n>Ty</span><span class=p>,</span> <span class=n>Tz</span><span class=p>,</span> <span class=mi>1</span><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div><p>Does it tell you though which convention you use? No. You can also write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>**float** m[16] = {  
</span></span><span class=line><span class=cl>AXx, AXy, AXz, Tx,  
</span></span><span class=line><span class=cl>AYx, AYy, AYz, Ty,  
</span></span><span class=line><span class=cl>AZx, AZy, AZz, Tz,  
</span></span><span class=line><span class=cl>0, 0, 0, 1};  
</span></span></code></pre></td></tr></table></div></div><p>or:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>m</span><span class=p>[</span><span class=mi>16</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl><span class=n>AXx</span><span class=p>,</span> <span class=n>AYx</span><span class=p>,</span> <span class=n>AZx</span><span class=p>,</span> <span class=n>Tx</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=n>AXy</span><span class=p>,</span> <span class=n>AYy</span><span class=p>,</span> <span class=n>AZy</span><span class=p>,</span> <span class=n>Ty</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=n>AXz</span><span class=p>,</span> <span class=n>AYz</span><span class=p>,</span> <span class=n>AZz</span><span class=p>,</span> <span class=n>Tz</span><span class=p>,</span>  
</span></span><span class=line><span class=cl><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div><p>Again, that doesn&rsquo;t give you a particular indication of which &ldquo;mathematical&rdquo; convention you use. You are just storing 16 coefficients in memory in different ways and that&rsquo;s perfectly fine as long as you know what that way is, so that you can access them appropriately later on. Now keep in mind that a vector multiplied by a matrix should give you the same vector whether you use a row- or column- mathematical notation. Thus what&rsquo;s important really is that you multiply the (x,y,z) coordinates of your vector by the right coefficients from the matrix, which requires the knowledge of how &ldquo;you&rdquo; have decided to store the matrix coefficient in memory:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Vector3</span> <span class=nf>vecMatMult</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=n>Vector3</span> <span class=n>v</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AXx</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AXy</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AXz</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>Tx</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AYx</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AYy</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AYz</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>Ty</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AZz</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AZy</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>AZz</span><span class=p>,</span> <span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>Tz</span>
</span></span><span class=line><span class=cl><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=o>**</span><span class=k>return</span><span class=o>**</span> <span class=n>Vector3</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>AXx</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>AYx</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>AZx</span> <span class=o>+</span> <span class=n>Tx</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>AXy</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>AYy</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>AZy</span> <span class=o>+</span> <span class=n>Ty</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>AXz</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>AZz</span> <span class=o>+</span> <span class=n>v</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>AZz</span> <span class=o>+</span> <span class=n>Tz</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div><p>We wrote this function to underline the fact that no matter which convention you use, the resulting of the vector * matrix multiplication is just a multiplication and an addition between the vector&rsquo;s input coordinates and the coordinate system&rsquo;s axis coordinates AX, AY and AZ (regardless of the notation you use, and regardless of the way you store them in memory). If you use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>m</span><span class=p>[</span><span class=mi>16</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>AXx</span><span class=p>,</span> <span class=n>AXy</span><span class=p>,</span> <span class=n>AXz</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>AYx</span><span class=p>,</span> <span class=n>AYy</span><span class=p>,</span> <span class=n>AYz</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>AZx</span><span class=p>,</span> <span class=n>AZy</span><span class=p>,</span> <span class=n>AZz</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>Tx</span><span class=p>,</span> <span class=n>Ty</span><span class=p>,</span> <span class=n>Tz</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div><p>You need to call:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vecMatMult(v, m[0], m[1], m[2], m[12], m[4], m[5], m[6], m[13], ...  
</span></span></code></pre></td></tr></table></div></div><p>If you use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kt>float</span><span class=o>**</span> <span class=n>m</span><span class=p>[</span><span class=mi>16</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=n>AXx</span><span class=p>,</span> <span class=n>AYx</span><span class=p>,</span> <span class=n>AZx</span><span class=p>,</span> <span class=n>Tx</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>AXy</span><span class=p>,</span> <span class=n>AYy</span><span class=p>,</span> <span class=n>AZy</span><span class=p>,</span> <span class=n>Ty</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=n>AXz</span><span class=p>,</span> <span class=n>AYz</span><span class=p>,</span> <span class=n>AZz</span><span class=p>,</span> <span class=n>Tz</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>	<span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div><p>You need to call:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>MatMult</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>4</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>8</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>3</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>5</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>9</span><span class=p>],</span> <span class=n>m</span><span class=p>[</span><span class=mi>10</span><span class=p>],</span> <span class=p>...</span>  
</span></span></code></pre></td></tr></table></div></div><p>Does that tell you which convention you use? No. You just need to call the right coefficients in the right places when you do a vec * mat multiplication. And that&rsquo;s all there is to it, as disconcerting as it may seem. Now things are slightly different when it comes to mat * mat multiplication. You can assume that the order in which you multiply the matrices is not the same. So R * S * T is not the same as T * S * R. The order indeed matters. Now again if you use &ldquo;row major&rdquo; then mathematically you need to write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mt11</span> <span class=o>=</span> <span class=n>ml11</span> <span class=o>*</span> <span class=n>mr11</span> <span class=o>+</span> <span class=n>ml12</span> <span class=o>*</span> <span class=n>mr21</span> <span class=o>+</span> <span class=n>ml13</span> <span class=o>*</span> <span class=n>mr31</span> <span class=o>+</span> <span class=n>ml14</span> <span class=o>*</span> <span class=n>mr41</span>  
</span></span></code></pre></td></tr></table></div></div><p>where ml is the left hand matrix and mr the right hand one: mt = ml * mr. However note that we haven&rsquo;t been using brackets [] for the access indices because we don&rsquo;t want to suggest we are accessing elements stored in a 1D array here. We are just talking about the coefficients of matrices as written on paper. If you want to write this in C++, then it all depends on how you have stored your coefficients in memory as suggested above.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/notes/3D-Modeling/blender/Sources/Scratchpixel/Scratchpixel-Home/ data-ctx="notes/3D-Modeling/blender/Sources/Scratchpixel/row major vs column major vector - scratchpixel" data-src=/notes/3D-Modeling/blender/Sources/Scratchpixel/Scratchpixel-Home class=internal-link>{{title}}</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://notes.benshurts.com/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Ben Shurts using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://notes.benshurts.com/>Home</a></li><li><a href=https://twitter.com/artofbenshurts>Twitter</a></li><li><a href=https://github.com/benshurts>Github</a></li></ul></footer></div></div></body></html>